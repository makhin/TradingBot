# SignalBot - Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚

## ĞĞ±Ğ·Ğ¾Ñ€

SignalBot - Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¸Ğ· Telegram ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ½Ğ° Binance Futures.

## Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

### ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹

```
1. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Telegram ĞºĞ°Ğ½Ğ°Ğ»Ñƒ Ñ‡ĞµÑ€ĞµĞ· WTelegramClient
2. ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ¼
3. ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ğ² ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
4. Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² (SL, leverage)
5. ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ½Ğ° Binance Futures
6. Ğ Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ Stop Loss Ğ¸ Take Profit Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
7. ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
8. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ…
9. Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
```

### Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ²Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²

```
#SYMBOL/USDT - LongğŸŸ¢ | ShortğŸ”´

Entry: X.XXXX
Stop Loss: X.XXXX

Target 1: X.XXXX
Target 2: X.XXXX
Target 3: X.XXXX
Target 4: X.XXXX

Leverage: xNN
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:**

```
#ICNT/USDT - LongğŸŸ¢

Entry: 0.3709
Stop Loss: 0.18569

Target 1: 0.37225
Target 2: 0.37243
Target 3: 0.37362
Target 4: 0.37452

Leverage: x32
```

```
#AVNT/USDT - LongğŸŸ¢

Entry: 0.3204
Stop Loss: 0.16064

Target 1: 0.32054
Target 2: 0.32303
Target 3: 0.3233
Target 4: 0.32379

Leverage: x32
```

---

## ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°

```
SignalBot/
â”œâ”€â”€ SignalBot.csproj
â”‚
â”œâ”€â”€ Program.cs                             # Entry point
â”œâ”€â”€ SignalBotRunner.cs                     # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ runner
â”‚
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Telegram/
â”‚   â”‚   â”œâ”€â”€ ITelegramSignalListener.cs     # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ TelegramSignalListener.cs      # WTelegramClient Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
â”‚   â”‚   â”œâ”€â”€ SignalParser.cs                # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ‚ĞµĞºÑÑ‚Ğ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
â”‚   â”‚   â””â”€â”€ SignalParserResult.cs          # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°
â”‚   â”‚
â”‚   â”œâ”€â”€ Validation/
â”‚   â”‚   â”œâ”€â”€ ISignalValidator.cs            # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ SignalValidator.cs             # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°
â”‚   â”‚   â””â”€â”€ ValidationResult.cs            # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
â”‚   â”‚
â”‚   â”œâ”€â”€ Trading/
â”‚   â”‚   â”œâ”€â”€ ISignalTrader.cs               # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ SignalTrader.cs                # Ğ˜ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
â”‚   â”‚   â”œâ”€â”€ IPositionManager.cs            # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ PositionManager.cs             # Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸ÑĞ¼Ğ¸
â”‚   â”‚   â””â”€â”€ TargetTracker.cs               # ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ targets
â”‚   â”‚
â”‚   â””â”€â”€ Monitoring/
â”‚       â”œâ”€â”€ OrderMonitor.cs                # ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
â”‚       â””â”€â”€ PositionMonitor.cs             # ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
â”‚
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ TradingSignal.cs                   # Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ¸Ğ· Telegram
â”‚   â”œâ”€â”€ SignalPosition.cs                  # ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñƒ
â”‚   â”œâ”€â”€ TargetLevel.cs                     # Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ take profit
â”‚   â”œâ”€â”€ SignalDirection.cs                 # Long/Short enum
â”‚   â”œâ”€â”€ PositionStatus.cs                  # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ enum
â”‚   â””â”€â”€ SignalSource.cs                    # Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
â”‚
â”œâ”€â”€ Configuration/
â”‚   â”œâ”€â”€ SignalBotSettings.cs               # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
â”‚   â”œâ”€â”€ TelegramSettings.cs                # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Telegram
â”‚   â”œâ”€â”€ TradingSettings.cs                 # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ğ¸
â”‚   â””â”€â”€ RiskOverrideSettings.cs            # ĞŸĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ñ€Ğ¸ÑĞºĞ°
â”‚
â”œâ”€â”€ State/
â”‚   â”œâ”€â”€ SignalBotState.cs                  # Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ°
â”‚   â””â”€â”€ SignalPositionStore.cs             # Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
â”‚
â””â”€â”€ appsettings.json
```

### Ğ”Ğ¸Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          SignalBot                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    Telegram     â”‚    â”‚    Signal    â”‚    â”‚     Signal      â”‚   â”‚
â”‚  â”‚    Listener     â”‚â”€â”€â”€â–¶â”‚    Parser    â”‚â”€â”€â”€â–¶â”‚    Validator    â”‚   â”‚
â”‚  â”‚                 â”‚    â”‚              â”‚    â”‚                 â”‚   â”‚
â”‚  â”‚ (WTelegramClient)â”‚    â”‚  (Regex)     â”‚    â”‚ (Risk checks)   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                       â”‚            â”‚
â”‚                                                       â–¼            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   Position      â”‚â—€â”€â”€â”€â”‚   Signal     â”‚â—€â”€â”€â”€â”‚   Trading       â”‚   â”‚
â”‚  â”‚   Manager       â”‚    â”‚   Trader     â”‚    â”‚   Signal        â”‚   â”‚
â”‚  â”‚                 â”‚    â”‚              â”‚    â”‚   (validated)   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚           â”‚                    â”‚                                   â”‚
â”‚           â–¼                    â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚   Position      â”‚    â”‚   Order      â”‚                          â”‚
â”‚  â”‚   Store         â”‚    â”‚   Monitor    â”‚                          â”‚
â”‚  â”‚                 â”‚    â”‚              â”‚                          â”‚
â”‚  â”‚ (JSON/SQLite)   â”‚    â”‚ (WebSocket)  â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                    â”‚
                â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TradingBot.Core     â”‚  â”‚  TradingBot.Binance   â”‚
â”‚                       â”‚  â”‚                       â”‚
â”‚ â€¢ IRiskManager        â”‚  â”‚ â€¢ IBinanceFuturesClientâ”‚
â”‚ â€¢ IStateManager       â”‚  â”‚ â€¢ IOrderUpdateListener â”‚
â”‚ â€¢ INotifier           â”‚  â”‚ â€¢ IKlineListener      â”‚
â”‚ â€¢ Models              â”‚  â”‚                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ĞœĞ¾Ğ´ĞµĞ»Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

### TradingSignal

```csharp
/// <summary>
/// Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ», Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ· Telegram ĞºĞ°Ğ½Ğ°Ğ»Ğ°
/// </summary>
public record TradingSignal
{
    // ĞœĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    public Guid Id { get; init; } = Guid.NewGuid();
    public string RawText { get; init; } = string.Empty;
    public DateTime ReceivedAt { get; init; } = DateTime.UtcNow;
    public SignalSource Source { get; init; }

    // Ğ Ğ°ÑĞ¿Ğ°Ñ€ÑĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    public string Symbol { get; init; } = string.Empty;        // "ICNTUSDT"
    public SignalDirection Direction { get; init; }             // Long/Short
    public decimal Entry { get; init; }                         // Ğ¦ĞµĞ½Ğ° Ğ²Ñ…Ğ¾Ğ´Ğ°
    public decimal OriginalStopLoss { get; init; }              // SL Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    public IReadOnlyList<decimal> Targets { get; init; } = [];  // T1, T2, T3, T4
    public int OriginalLeverage { get; init; }                  // Leverage Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°

    // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ/ÑĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
    public decimal AdjustedStopLoss { get; init; }              // Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ SL
    public int AdjustedLeverage { get; init; }                  // Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ leverage
    public decimal LiquidationPrice { get; init; }              // Ğ¦ĞµĞ½Ğ° Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
    public decimal RiskRewardRatio { get; init; }               // R:R Ğ´Ğ¾ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ target

    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
    public bool IsValid { get; init; }
    public IReadOnlyList<string> ValidationWarnings { get; init; } = [];
}

public enum SignalDirection
{
    Long,
    Short
}

public record SignalSource
{
    public string ChannelName { get; init; } = string.Empty;
    public long ChannelId { get; init; }
    public int MessageId { get; init; }
}
```

### SignalPosition

```csharp
/// <summary>
/// ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñƒ
/// </summary>
public record SignalPosition
{
    // Ğ˜Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid SignalId { get; init; }

    // ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    public string Symbol { get; init; } = string.Empty;
    public SignalDirection Direction { get; init; }
    public PositionStatus Status { get; init; }

    // Ğ¦ĞµĞ½Ñ‹
    public decimal PlannedEntryPrice { get; init; }
    public decimal ActualEntryPrice { get; init; }
    public decimal CurrentStopLoss { get; init; }
    public int Leverage { get; init; }

    // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾
    public decimal InitialQuantity { get; init; }
    public decimal RemainingQuantity { get; init; }
    public decimal FilledQuantity => InitialQuantity - RemainingQuantity;

    // Targets
    public IReadOnlyList<TargetLevel> Targets { get; init; } = [];
    public int TargetsHit => Targets.Count(t => t.IsHit);

    // ĞÑ€Ğ´ĞµÑ€Ğ° Ğ½Ğ° Ğ±Ğ¸Ñ€Ğ¶Ğµ
    public long? EntryOrderId { get; init; }
    public long? StopLossOrderId { get; init; }
    public IReadOnlyList<long> TakeProfitOrderIds { get; init; } = [];

    // Ğ’Ñ€ĞµĞ¼Ñ
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
    public DateTime? OpenedAt { get; init; }
    public DateTime? ClosedAt { get; init; }

    // P&L
    public decimal RealizedPnl { get; init; }
    public decimal UnrealizedPnl { get; init; }
    public decimal Commission { get; init; }

    // ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ
    public PositionCloseReason? CloseReason { get; init; }
}

public enum PositionStatus
{
    Pending,         // Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½, Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
    Opening,         // ĞÑ€Ğ´ĞµÑ€ Ğ½Ğ° Ğ²Ñ…Ğ¾Ğ´ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½
    Open,            // ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°
    PartialClosed,   // Ğ§Ğ°ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ° Ğ¿Ğ¾ targets
    Closing,         // Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ
    Closed,          // ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°
    Cancelled,       // ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ´Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ
    Failed           // ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸
}

public enum PositionCloseReason
{
    AllTargetsHit,
    StopLossHit,
    ManualClose,
    Liquidation,
    Error
}
```

### TargetLevel

```csharp
/// <summary>
/// Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ take profit
/// </summary>
public record TargetLevel
{
    public int Index { get; init; }                    // 0, 1, 2, 3
    public decimal Price { get; init; }                // Ğ¦ĞµĞ½Ğ° target
    public decimal PercentToClose { get; init; }       // % Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ (25%)
    public decimal QuantityToClose { get; init; }      // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ

    public bool IsHit { get; init; }
    public DateTime? HitAt { get; init; }
    public decimal? ActualClosePrice { get; init; }
    public long? OrderId { get; init; }

    // Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ
    public decimal? MoveStopLossTo { get; init; }      // ĞšÑƒĞ´Ğ° Ğ´Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒ SL Ğ¿Ğ¾ÑĞ»Ğµ hit
}
```

### SignalBotState

```csharp
/// <summary>
/// Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ° Ğ´Ğ»Ñ persistence
/// </summary>
public record SignalBotState
{
    public DateTime LastUpdate { get; init; } = DateTime.UtcNow;
    public string Version { get; init; } = "1.0";

    // ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    public IReadOnlyList<SignalPosition> OpenPositions { get; init; } = [];

    // ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ (Ğ½Ğµ ÑƒÑĞ¿ĞµĞ»Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ)
    public IReadOnlyList<TradingSignal> PendingSignals { get; init; } = [];

    // Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞµÑÑĞ¸Ğ¸
    public decimal SessionStartEquity { get; init; }
    public decimal CurrentEquity { get; init; }
    public int TotalSignalsReceived { get; init; }
    public int TotalPositionsOpened { get; init; }
    public int TotalPositionsClosed { get; init; }

    // ID Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ (Ğ´Ğ»Ñ Ğ´ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸)
    public Dictionary<long, int> LastProcessedMessageIds { get; init; } = new();
}
```

---

## ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

### appsettings.json

```json
{
  "SignalBot": {
    "Telegram": {
      "ApiId": 12345678,
      "ApiHash": "your_api_hash",
      "PhoneNumber": "+1234567890",
      "ChannelIds": [
        -1001234567890
      ],
      "SessionPath": "telegram_session.dat"
    },

    "Trading": {
      "DefaultSymbolSuffix": "USDT",
      "MarginType": "Isolated",
      "PositionMode": "OneWay",

      "EntryMode": "Market",
      "MaxConcurrentPositions": 5,
      "MinTimeBetweenSignals": "00:01:00",

      "TargetStrategy": "PartialClose",
      "TargetClosePercents": [25, 25, 25, 25],
      "MoveStopToBreakeven": true,
      "TrailingStopEnabled": false
    },

    "DuplicateHandling": {
      "SameDirection": "Ignore",
      "OppositeDirection": "Ignore",
      "MaxPositionsPerSymbol": 1,
      "MinTimeBetweenDuplicates": "00:05:00",
      "AllowDuplicateOnPartialClose": true
    },

    "PositionSizing": {
      "DefaultMode": "FixedAmount",
      "DefaultRiskPercent": 1.0,
      "DefaultFixedAmount": 100.0,
      "DefaultFixedMargin": 50.0,

      "SymbolOverrides": {
        "BTCUSDT": { "FixedAmount": 200.0 },
        "ETHUSDT": { "FixedAmount": 150.0 }
      },

      "Limits": {
        "MinPositionUsdt": 10.0,
        "MaxPositionUsdt": 1000.0,
        "MaxPositionPercent": 25.0,
        "MaxTotalExposurePercent": 80.0
      }
    },

    "RiskOverride": {
      "Enabled": true,
      "MaxLeverage": 10,
      "UseSignalLeverage": false,

      "StopLossMode": "Calculate",
      "StopLossPercent": 2.0,
      "SafeDistanceFromLiquidation": 0.3,

      "RiskPerTradePercent": 1.0,
      "MaxDrawdownPercent": 20.0,
      "MaxDailyLossPercent": 5.0
    },

    "Notifications": {
      "TelegramBotToken": "your_bot_token",
      "TelegramChatId": "your_chat_id",
      "NotifyOnSignalReceived": true,
      "NotifyOnPositionOpened": true,
      "NotifyOnTargetHit": true,
      "NotifyOnPositionClosed": true,
      "NotifyOnError": true
    },

    "State": {
      "StatePath": "signalbot_state.json",
      "BackupEnabled": true,
      "AutoSaveIntervalSeconds": 30
    }
  },

  "BinanceApi": {
    "UseTestnet": true,
    "ApiKey": "",
    "ApiSecret": ""
  },

  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "SignalBot": "Debug"
    }
  }
}
```

### ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ (.env)

```bash
# Telegram API (https://my.telegram.org)
TELEGRAM_API_ID=12345678
TELEGRAM_API_HASH=your_api_hash
TELEGRAM_PHONE=+1234567890

# Telegram Bot Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
TELEGRAM_BOT_TOKEN=your_bot_token
TELEGRAM_CHAT_ID=your_chat_id

# Binance Futures Testnet
BINANCE_TESTNET_KEY=your_testnet_key
BINANCE_TESTNET_SECRET=your_testnet_secret

# Binance Futures Mainnet
BINANCE_MAINNET_KEY=your_mainnet_key
BINANCE_MAINNET_SECRET=your_mainnet_secret

# Mode
TRADING_BinanceApi__UseTestnet=true
```

---

## ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹

### SignalParser

```csharp
public class SignalParser
{
    // ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ regex Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°
    private static readonly Regex SignalRegex = new(
        @"#(?<symbol>\w+)/USDT\s*-\s*(?<direction>Long|Short)[ğŸŸ¢ğŸ”´]?\s*" +
        @"Entry:\s*(?<entry>[\d.]+)\s*" +
        @"Stop\s*Loss:\s*(?<sl>[\d.]+)\s*" +
        @"(?:Target\s*1:\s*(?<t1>[\d.]+)\s*)?" +
        @"(?:Target\s*2:\s*(?<t2>[\d.]+)\s*)?" +
        @"(?:Target\s*3:\s*(?<t3>[\d.]+)\s*)?" +
        @"(?:Target\s*4:\s*(?<t4>[\d.]+)\s*)?" +
        @"Leverage:\s*x(?<leverage>\d+)",
        RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

    public SignalParserResult Parse(string text)
    {
        var match = SignalRegex.Match(text);

        if (!match.Success)
            return SignalParserResult.Failed("Signal format not recognized");

        var targets = new List<decimal>();
        for (int i = 1; i <= 4; i++)
        {
            var group = match.Groups[$"t{i}"];
            if (group.Success && decimal.TryParse(group.Value,
                NumberStyles.Any, CultureInfo.InvariantCulture, out var target))
            {
                targets.Add(target);
            }
        }

        return SignalParserResult.Success(new TradingSignal
        {
            RawText = text,
            Symbol = match.Groups["symbol"].Value.ToUpperInvariant() + "USDT",
            Direction = match.Groups["direction"].Value.Equals("Long",
                StringComparison.OrdinalIgnoreCase)
                    ? SignalDirection.Long
                    : SignalDirection.Short,
            Entry = decimal.Parse(match.Groups["entry"].Value, CultureInfo.InvariantCulture),
            OriginalStopLoss = decimal.Parse(match.Groups["sl"].Value, CultureInfo.InvariantCulture),
            Targets = targets,
            OriginalLeverage = int.Parse(match.Groups["leverage"].Value)
        });
    }
}
```

### SignalValidator

```csharp
public class SignalValidator : ISignalValidator
{
    private readonly RiskOverrideSettings _settings;
    private readonly IBinanceFuturesClient _client;

    public async Task<ValidationResult> ValidateAndAdjustAsync(
        TradingSignal signal,
        decimal accountEquity,
        CancellationToken ct = default)
    {
        var warnings = new List<string>();

        // 1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°
        var symbolInfo = await _client.GetSymbolInfoAsync(signal.Symbol, ct);
        if (symbolInfo == null)
            return ValidationResult.Failed($"Symbol {signal.Symbol} not found");

        // 2. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ leverage
        int leverage = _settings.UseSignalLeverage
            ? Math.Min(signal.OriginalLeverage, _settings.MaxLeverage)
            : _settings.MaxLeverage;

        if (leverage != signal.OriginalLeverage)
            warnings.Add($"Leverage adjusted: {signal.OriginalLeverage}x â†’ {leverage}x");

        // 3. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
        decimal liquidationPrice = CalculateLiquidationPrice(
            signal.Entry,
            signal.Direction,
            leverage);

        // 4. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Stop Loss
        decimal stopLoss;

        if (_settings.StopLossMode == StopLossMode.FromSignal)
        {
            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‡Ñ‚Ğ¾ SL Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶Ğ¸Ğ¼ Ğ´Ğ¾ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
            bool slIsValid = signal.Direction == SignalDirection.Long
                ? signal.OriginalStopLoss > liquidationPrice
                : signal.OriginalStopLoss < liquidationPrice;

            if (slIsValid)
            {
                stopLoss = signal.OriginalStopLoss;
            }
            else
            {
                stopLoss = CalculateSafeStopLoss(signal.Entry, liquidationPrice, signal.Direction);
                warnings.Add($"SL unreachable (liquidation first), adjusted to {stopLoss}");
            }
        }
        else // Calculate
        {
            stopLoss = CalculateSafeStopLoss(signal.Entry, liquidationPrice, signal.Direction);
            warnings.Add($"SL calculated: {stopLoss} (signal SL ignored: {signal.OriginalStopLoss})");
        }

        // 5. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ R:R
        decimal targetPrice = signal.Targets.FirstOrDefault();
        decimal riskReward = targetPrice > 0
            ? CalculateRiskReward(signal.Entry, stopLoss, targetPrice, signal.Direction)
            : 0;

        if (riskReward < 1.0m && riskReward > 0)
            warnings.Add($"Poor Risk:Reward ratio: {riskReward:F2}");

        // 6. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        // (Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾ Ğ¿Ñ€Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ğ¸)

        return ValidationResult.Success(signal with
        {
            AdjustedStopLoss = stopLoss,
            AdjustedLeverage = leverage,
            LiquidationPrice = liquidationPrice,
            RiskRewardRatio = riskReward,
            IsValid = true,
            ValidationWarnings = warnings
        });
    }

    private decimal CalculateLiquidationPrice(decimal entry, SignalDirection direction, int leverage)
    {
        // Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ°Ñ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ° (Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ margin type, maintenance margin, etc.)
        decimal liquidationDistance = entry / leverage;

        return direction == SignalDirection.Long
            ? entry - liquidationDistance * 0.98m  // ~2% buffer
            : entry + liquidationDistance * 0.98m;
    }

    private decimal CalculateSafeStopLoss(decimal entry, decimal liquidationPrice, SignalDirection direction)
    {
        // SL Ğ½Ğ° 30% Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¾Ñ‚ entry Ğ´Ğ¾ liquidation
        decimal distance = Math.Abs(entry - liquidationPrice);
        decimal safeDistance = distance * _settings.SafeDistanceFromLiquidation;

        return direction == SignalDirection.Long
            ? entry - safeDistance
            : entry + safeDistance;
    }

    private decimal CalculateRiskReward(decimal entry, decimal stopLoss, decimal target, SignalDirection direction)
    {
        decimal risk = Math.Abs(entry - stopLoss);
        decimal reward = Math.Abs(target - entry);

        return risk > 0 ? reward / risk : 0;
    }
}
```

### SignalTrader

```csharp
public class SignalTrader : ISignalTrader
{
    private readonly IBinanceFuturesClient _client;
    private readonly IPositionManager _positionManager;
    private readonly IRiskManager _riskManager;
    private readonly TradingSettings _settings;
    private readonly ILogger<SignalTrader> _logger;

    public async Task<SignalPosition> ExecuteSignalAsync(
        TradingSignal signal,
        decimal accountEquity,
        CancellationToken ct = default)
    {
        // 1. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² ÑÑ‚Ğ°Ñ‚ÑƒÑĞµ Pending
        var position = new SignalPosition
        {
            SignalId = signal.Id,
            Symbol = signal.Symbol,
            Direction = signal.Direction,
            Status = PositionStatus.Pending,
            PlannedEntryPrice = signal.Entry,
            CurrentStopLoss = signal.AdjustedStopLoss,
            Leverage = signal.AdjustedLeverage,
            Targets = CreateTargetLevels(signal)
        };

        await _positionManager.SavePositionAsync(position, ct);

        try
        {
            // 2. Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ leverage
            await _client.SetLeverageAsync(signal.Symbol, signal.AdjustedLeverage, ct);
            await _client.SetMarginTypeAsync(signal.Symbol, MarginType.Isolated, ct);

            // 3. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
            var positionSize = _riskManager.CalculatePositionSize(
                accountEquity,
                signal.Entry,
                signal.AdjustedStopLoss);

            position = position with
            {
                InitialQuantity = positionSize.Quantity,
                RemainingQuantity = positionSize.Quantity,
                Status = PositionStatus.Opening
            };
            await _positionManager.SavePositionAsync(position, ct);

            // 4. ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ (Market order)
            var entryOrder = await _client.PlaceMarketOrderAsync(new OrderRequest
            {
                Symbol = signal.Symbol,
                Side = signal.Direction == SignalDirection.Long ? OrderSide.Buy : OrderSide.Sell,
                Quantity = positionSize.Quantity
            }, ct);

            if (!entryOrder.IsSuccess)
            {
                position = position with { Status = PositionStatus.Failed };
                await _positionManager.SavePositionAsync(position, ct);
                throw new TradingException($"Entry order failed: {entryOrder.Error}");
            }

            position = position with
            {
                EntryOrderId = entryOrder.OrderId,
                ActualEntryPrice = entryOrder.AveragePrice,
                OpenedAt = DateTime.UtcNow,
                Status = PositionStatus.Open
            };

            // 5. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Stop Loss
            var slOrder = await _client.PlaceStopMarketOrderAsync(new OrderRequest
            {
                Symbol = signal.Symbol,
                Side = signal.Direction == SignalDirection.Long ? OrderSide.Sell : OrderSide.Buy,
                Quantity = positionSize.Quantity,
                StopPrice = signal.AdjustedStopLoss,
                ReduceOnly = true
            }, ct);

            position = position with { StopLossOrderId = slOrder.OrderId };

            // 6. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Take Profit Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
            var tpOrderIds = new List<long>();
            foreach (var target in position.Targets)
            {
                var tpOrder = await _client.PlaceTakeProfitMarketOrderAsync(new OrderRequest
                {
                    Symbol = signal.Symbol,
                    Side = signal.Direction == SignalDirection.Long ? OrderSide.Sell : OrderSide.Buy,
                    Quantity = target.QuantityToClose,
                    StopPrice = target.Price,
                    ReduceOnly = true
                }, ct);

                tpOrderIds.Add(tpOrder.OrderId);
            }

            position = position with { TakeProfitOrderIds = tpOrderIds };
            await _positionManager.SavePositionAsync(position, ct);

            _logger.LogInformation(
                "Position opened: {Symbol} {Direction} @ {Price}, SL: {SL}, Qty: {Qty}",
                position.Symbol, position.Direction, position.ActualEntryPrice,
                position.CurrentStopLoss, position.InitialQuantity);

            return position;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to execute signal {SignalId}", signal.Id);

            position = position with { Status = PositionStatus.Failed };
            await _positionManager.SavePositionAsync(position, ct);

            throw;
        }
    }

    private IReadOnlyList<TargetLevel> CreateTargetLevels(TradingSignal signal)
    {
        var targets = new List<TargetLevel>();
        var percents = _settings.TargetClosePercents;

        for (int i = 0; i < signal.Targets.Count && i < percents.Count; i++)
        {
            decimal moveSlTo = i == 0
                ? signal.Entry  // ĞŸĞ¾ÑĞ»Ğµ T1 Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ SL Ğ½Ğ° breakeven
                : signal.Targets[i - 1];  // ĞŸĞ¾ÑĞ»Ğµ T2 Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ Ğ½Ğ° T1, etc.

            targets.Add(new TargetLevel
            {
                Index = i,
                Price = signal.Targets[i],
                PercentToClose = percents[i],
                MoveStopLossTo = _settings.MoveStopToBreakeven ? moveSlTo : null
            });
        }

        return targets;
    }
}
```

### PositionManager

```csharp
public class PositionManager : IPositionManager
{
    private readonly IPositionStore<SignalPosition> _store;
    private readonly IBinanceFuturesClient _client;
    private readonly INotifier _notifier;
    private readonly ILogger<PositionManager> _logger;

    public async Task HandleTargetHitAsync(
        SignalPosition position,
        int targetIndex,
        decimal fillPrice,
        CancellationToken ct = default)
    {
        var target = position.Targets[targetIndex];

        // 1. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ target ĞºĞ°Ğº hit
        var updatedTargets = position.Targets.Select((t, i) => i == targetIndex
            ? t with { IsHit = true, HitAt = DateTime.UtcNow, ActualClosePrice = fillPrice }
            : t).ToList();

        // 2. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ remaining quantity
        decimal closedQty = target.QuantityToClose;
        decimal newRemaining = position.RemainingQuantity - closedQty;

        // 3. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ realized PnL Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚Ğ¸
        decimal pnl = CalculatePnl(
            position.ActualEntryPrice,
            fillPrice,
            closedQty,
            position.Direction);

        // 4. Ğ”Ğ²Ğ¸Ğ½ÑƒÑ‚ÑŒ Stop Loss ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
        if (target.MoveStopLossTo.HasValue)
        {
            await MoveStopLossAsync(position, target.MoveStopLossTo.Value, newRemaining, ct);
        }

        // 5. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        var updatedPosition = position with
        {
            Targets = updatedTargets,
            RemainingQuantity = newRemaining,
            RealizedPnl = position.RealizedPnl + pnl,
            Status = newRemaining <= 0 ? PositionStatus.Closed : PositionStatus.PartialClosed,
            ClosedAt = newRemaining <= 0 ? DateTime.UtcNow : null,
            CloseReason = newRemaining <= 0 ? PositionCloseReason.AllTargetsHit : null
        };

        await _store.SavePositionAsync(updatedPosition, ct);

        // 6. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
        await _notifier.SendMessageAsync(
            $"ğŸ¯ Target {targetIndex + 1} hit!\n" +
            $"Symbol: {position.Symbol}\n" +
            $"Price: {fillPrice}\n" +
            $"PnL: {pnl:+0.00;-0.00} USDT\n" +
            $"Remaining: {newRemaining}",
            ct);

        _logger.LogInformation(
            "Target {Index} hit for {Symbol}: {Price}, PnL: {Pnl}",
            targetIndex + 1, position.Symbol, fillPrice, pnl);
    }

    public async Task HandleStopLossHitAsync(
        SignalPosition position,
        decimal fillPrice,
        CancellationToken ct = default)
    {
        // 1. ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ TP Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        foreach (var orderId in position.TakeProfitOrderIds)
        {
            await _client.CancelOrderAsync(position.Symbol, orderId, ct);
        }

        // 2. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ PnL
        decimal pnl = CalculatePnl(
            position.ActualEntryPrice,
            fillPrice,
            position.RemainingQuantity,
            position.Direction);

        // 3. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        var updatedPosition = position with
        {
            RemainingQuantity = 0,
            RealizedPnl = position.RealizedPnl + pnl,
            Status = PositionStatus.Closed,
            ClosedAt = DateTime.UtcNow,
            CloseReason = PositionCloseReason.StopLossHit
        };

        await _store.SavePositionAsync(updatedPosition, ct);

        // 4. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
        await _notifier.SendAlertAsync(
            "ğŸ›‘ Stop Loss Hit",
            $"Symbol: {position.Symbol}\n" +
            $"Entry: {position.ActualEntryPrice}\n" +
            $"Exit: {fillPrice}\n" +
            $"Total PnL: {updatedPosition.RealizedPnl:+0.00;-0.00} USDT",
            ct);
    }

    private async Task MoveStopLossAsync(
        SignalPosition position,
        decimal newStopLoss,
        decimal quantity,
        CancellationToken ct)
    {
        // 1. ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ SL
        if (position.StopLossOrderId.HasValue)
        {
            await _client.CancelOrderAsync(position.Symbol, position.StopLossOrderId.Value, ct);
        }

        // 2. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ SL
        var newSlOrder = await _client.PlaceStopMarketOrderAsync(new OrderRequest
        {
            Symbol = position.Symbol,
            Side = position.Direction == SignalDirection.Long ? OrderSide.Sell : OrderSide.Buy,
            Quantity = quantity,
            StopPrice = newStopLoss,
            ReduceOnly = true
        }, ct);

        _logger.LogInformation(
            "Stop loss moved for {Symbol}: {OldSL} â†’ {NewSL}",
            position.Symbol, position.CurrentStopLoss, newStopLoss);
    }

    private decimal CalculatePnl(decimal entry, decimal exit, decimal quantity, SignalDirection direction)
    {
        decimal priceDiff = direction == SignalDirection.Long
            ? exit - entry
            : entry - exit;

        return priceDiff * quantity;
    }
}
```

---

## Workflow

### ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SIGNAL PROCESSING FLOW                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram   â”‚
â”‚  Channel    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ New message
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram   â”‚     â”‚ Duplicate   â”‚
â”‚  Listener   â”‚â”€â”€â”€â”€â–¶â”‚ Check       â”‚â”€â”€â”€â”€ Already processed? â”€â”€â–¶ Skip
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Signal     â”‚â”€â”€â”€â”€ Parse failed? â”€â”€â–¶ Log warning, skip
â”‚  Parser     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ TradingSignal
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Signal     â”‚â”€â”€â”€â”€ Validation failed? â”€â”€â–¶ Notify, skip
â”‚  Validator  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Validated signal
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Concurrent  â”‚â”€â”€â”€â”€ Too many positions? â”€â”€â–¶ Queue or skip
â”‚ Position    â”‚
â”‚ Check       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Signal     â”‚â”€â”€â”€â”€ Order failed? â”€â”€â–¶ Notify error
â”‚  Trader     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Position opened
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Position   â”‚
â”‚  Manager    â”‚
â”‚  (monitor)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    POSITION CLOSE FLOW                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WebSocket  â”‚
â”‚  Order      â”‚
â”‚  Updates    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Order filled event
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Order      â”‚
â”‚  Monitor    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€ Stop Loss Order? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                                      â–¼
       â”‚                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                             â”‚ Handle SL   â”‚
       â”‚                             â”‚ - Cancel TPsâ”‚
       â”‚                             â”‚ - Calc PnL  â”‚
       â”‚                             â”‚ - Close pos â”‚
       â”‚                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â””â”€â”€â”€ Take Profit Order? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                              â–¼
                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                     â”‚ Handle TP   â”‚
                                     â”‚ - Update qtyâ”‚
                                     â”‚ - Move SL   â”‚
                                     â”‚ - Calc PnL  â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚                           â”‚
                              â–¼                           â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚ More targetsâ”‚            â”‚ All targets â”‚
                     â”‚ remaining   â”‚            â”‚ hit         â”‚
                     â”‚             â”‚            â”‚             â”‚
                     â”‚ Keep        â”‚            â”‚ Close       â”‚
                     â”‚ monitoring  â”‚            â”‚ position    â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Startup Ğ¸ Shutdown

### Startup Flow

```csharp
public class SignalBotRunner
{
    public async Task RunAsync(CancellationToken ct)
    {
        // 1. Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
        var state = await _stateManager.LoadStateAsync(ct);

        if (state != null)
        {
            _logger.LogInformation("Restored state: {Positions} open positions",
                state.OpenPositions.Count);

            // 2. Reconcile Ñ Ğ±Ğ¸Ñ€Ğ¶ĞµĞ¹
            var reconcileResult = await _reconciler.ReconcileAsync(state, ct);

            foreach (var mismatch in reconcileResult.PositionsMismatch)
            {
                _logger.LogWarning("Position mismatch: {Symbol} - local vs exchange",
                    mismatch.Symbol);
            }

            // 3. Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
            foreach (var position in reconcileResult.PositionsConfirmed)
            {
                await _positionManager.StartMonitoringAsync(position, ct);
            }
        }

        // 4. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ
        var account = await _client.GetAccountInfoAsync(ct);
        _logger.LogInformation("Account balance: {Balance} USDT", account.Balance);

        // 5. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Telegram
        await _telegramListener.ConnectAsync(ct);

        // 6. ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° WebSocket Ğ´Ğ»Ñ order updates
        await _orderMonitor.StartAsync(ct);

        // 7. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
        await _telegramListener.StartListeningAsync(OnSignalReceived, ct);

        _logger.LogInformation("SignalBot started successfully");

        // 8. Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
        await ct.WhenCanceled();
    }
}
```

### Shutdown Flow

```csharp
public async Task ShutdownAsync(ShutdownAction action, CancellationToken ct)
{
    _logger.LogInformation("Initiating shutdown with action: {Action}", action);

    // 1. ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ñ‘Ğ¼ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
    await _telegramListener.StopListeningAsync(ct);

    // 2. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    await _stateManager.SaveStateAsync(BuildCurrentState(), ct);

    // 3. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ
    switch (action)
    {
        case ShutdownAction.KeepPositionsAndOrders:
            // ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµĞ¼ - Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¸ Ğ¾Ñ€Ğ´ĞµÑ€Ğ° Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ Ğ½Ğ° Ğ±Ğ¸Ñ€Ğ¶Ğµ
            break;

        case ShutdownAction.ClosePositions:
            foreach (var position in _openPositions)
            {
                await ClosePositionAtMarketAsync(position, ct);
            }
            break;

        case ShutdownAction.CancelOrdersKeepPositions:
            // ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ SL/TP, Ğ½Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ (ĞĞŸĞĞ¡ĞĞ!)
            foreach (var position in _openPositions)
            {
                await CancelAllOrdersAsync(position, ct);
            }
            break;
    }

    // 4. ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ñ‚ WebSocket
    await _orderMonitor.StopAsync(ct);

    // 5. ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ñ‚ Telegram
    await _telegramListener.DisconnectAsync(ct);

    // 6. Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
    await _stateManager.SaveStateAsync(BuildCurrentState(), ct);

    // 7. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
    await _notifier.SendMessageAsync(
        $"ğŸ”´ SignalBot shutdown\nAction: {action}\nPositions: {_openPositions.Count}",
        ct);
}
```

---

## Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

### NuGet Ğ¿Ğ°ĞºĞµÑ‚Ñ‹

```xml
<ItemGroup>
  <!-- Telegram -->
  <PackageReference Include="WTelegramClient" Version="4.0.0" />

  <!-- Logging -->
  <PackageReference Include="Serilog" Version="3.1.1" />
  <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
  <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />

  <!-- Configuration -->
  <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
  <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
  <PackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="8.0.0" />
  <PackageReference Include="DotNetEnv" Version="3.0.0" />

  <!-- CLI -->
  <PackageReference Include="Spectre.Console" Version="0.49.1" />
</ItemGroup>

<ItemGroup>
  <ProjectReference Include="..\TradingBot.Core\TradingBot.Core.csproj" />
  <ProjectReference Include="..\TradingBot.Binance\TradingBot.Binance.csproj" />
</ItemGroup>
```

---

## Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

### Unit Tests

```
SignalBot.Tests/
â”œâ”€â”€ Parsing/
â”‚   â”œâ”€â”€ SignalParserTests.cs           # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ²
â”‚   â””â”€â”€ SignalParserEdgeCasesTests.cs  # Edge cases, Ğ½ĞµĞ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹
â”‚
â”œâ”€â”€ Validation/
â”‚   â”œâ”€â”€ SignalValidatorTests.cs        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
â”‚   â””â”€â”€ LiquidationCalculatorTests.cs  # Ğ Ğ°ÑÑ‡Ñ‘Ñ‚ Ñ†ĞµĞ½Ñ‹ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
â”‚
â”œâ”€â”€ Trading/
â”‚   â”œâ”€â”€ SignalTraderTests.cs           # Mock Binance client
â”‚   â””â”€â”€ PositionManagerTests.cs        # Target hit, SL hit scenarios
â”‚
â””â”€â”€ State/
    â””â”€â”€ StateRecoveryTests.cs          # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ restart
```

### Integration Tests

```
SignalBot.Integration/
â”œâ”€â”€ TelegramListenerTests.cs           # Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº TG
â”œâ”€â”€ BinanceFuturesTests.cs             # Testnet trading
â””â”€â”€ EndToEndTests.cs                   # ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» ÑĞ¸Ğ³Ğ½Ğ°Ğ» â†’ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ â†’ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
```

---

## ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¸ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸

### Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

```
[2024-01-15 10:30:15 INF] Signal received from channel "CryptoSignals"
[2024-01-15 10:30:15 INF] Parsed signal: ICNTUSDT Long @ 0.3709
[2024-01-15 10:30:15 WRN] SL adjusted: 0.18569 â†’ 0.3593 (original unreachable)
[2024-01-15 10:30:15 WRN] Leverage adjusted: 32x â†’ 10x (max limit)
[2024-01-15 10:30:16 INF] Position opened: ICNTUSDT Long @ 0.3710, Qty: 100
[2024-01-15 10:30:16 INF] SL order placed: 12345 @ 0.3593
[2024-01-15 10:30:16 INF] TP orders placed: 12346, 12347, 12348, 12349
[2024-01-15 10:45:30 INF] Target 1 hit: ICNTUSDT @ 0.37225, PnL: +1.35 USDT
[2024-01-15 10:45:30 INF] SL moved: 0.3593 â†’ 0.3709 (breakeven)
```

### Telegram ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ

```
ğŸ“¥ Signal Received
Symbol: ICNTUSDT
Direction: Long
Entry: 0.3709
Adjusted SL: 0.3593 (was 0.18569)
Targets: 0.37225, 0.37243, 0.37362, 0.37452
Leverage: 10x (was 32x)

---

âœ… Position Opened
Symbol: ICNTUSDT Long
Entry: 0.3710
Quantity: 100
Stop Loss: 0.3593
Risk: 1.0% ($10.00)

---

ğŸ¯ Target 1 Hit!
Symbol: ICNTUSDT
Price: 0.37225
Closed: 25 (25%)
PnL: +1.35 USDT
SL moved to: 0.3709 (breakeven)

---

ğŸ›‘ Stop Loss Hit
Symbol: ICNTUSDT
Entry: 0.3710
Exit: 0.3593
Total PnL: -3.51 USDT
```

---

## ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€ÑƒÑÑ‰Ğ¸Ñ…ÑÑ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²

### ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°

Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ, ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ, Ğ¿Ğ¾ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼Ñƒ ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ?

### Ğ ĞµĞ¶Ğ¸Ğ¼Ñ‹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ (DuplicateSignalHandling)

```csharp
public enum DuplicateSignalHandling
{
    /// <summary>
    /// Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ», Ğ¿Ğ¾ĞºĞ° ĞµÑÑ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
    /// </summary>
    Ignore,

    /// <summary>
    /// ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ (DCA/pyramid)
    /// </summary>
    OpenNew,

    /// <summary>
    /// ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ targets Ğ¸ SL ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    /// </summary>
    UpdateTargets,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ
    /// </summary>
    CloseAndReopen
}
```

### Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸

```
                         ĞĞ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½
                                â”‚
                                â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Ğ•ÑÑ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ â”‚
                    â”‚    Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ?  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                       â”‚
                   ĞĞµÑ‚                     Ğ”Ğ°
                    â”‚                       â”‚
                    â–¼                       â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ  â”‚       â”‚ ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚â”‚
              â”‚ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ  â”‚       â”‚ (Long â†’ Long)?      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚                           â”‚
                             Ğ”Ğ°                          ĞĞµÑ‚
                              â”‚                           â”‚
                              â–¼                           â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼    â”‚      â”‚ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼    â”‚
                 â”‚ DuplicateHandling  â”‚      â”‚ OppositeSignal     â”‚
                 â”‚ Ğ´Ğ»Ñ same-direction â”‚      â”‚ Handling           â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° (OppositeSignalHandling)

```csharp
public enum OppositeSignalHandling
{
    /// <summary>
    /// Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ»
    /// </summary>
    Ignore,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ğ½Ğ¾ Ğ½Ğµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ
    /// </summary>
    CloseOnly,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ² Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸
    /// </summary>
    Reverse
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ignore (ĞºĞ¾Ğ½ÑĞµÑ€Ğ²Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ BTCUSDT
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long (Ğ½Ğ¾Ğ²Ñ‹Ğµ targets)
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:  Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼, Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ "Signal ignored: position already open"
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: OpenNew (DCA/ÑƒÑÑ€ĞµĞ´Ğ½ĞµĞ½Ğ¸Ğµ)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ BTCUSDT @ 50000, qty: 0.1
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long @ 48000 (Ñ†ĞµĞ½Ğ° ÑƒĞ¿Ğ°Ğ»Ğ°)
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:  ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²Ñ‚Ğ¾Ñ€ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ñ‚ĞµĞ¿ĞµÑ€ÑŒ 2 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ BTC
Ğ Ğ¸ÑĞº:      Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ĞµĞ½Ğ½Ğ°Ñ ÑĞºÑĞ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ½Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ğ°ĞºÑ‚Ğ¸Ğ²
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: UpdateTargets (Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long BTCUSDT, SL: 49000, Targets: [51000, 52000]
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long, SL: 49500, Targets: [51500, 52500]
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:
  1. ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ SL/TP Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
  2. Ğ Ğ°Ğ·Ğ¼ĞµÑ‰Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğµ SL: 49500, TP: [51500, 52500]
  3. ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ SignalPosition
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 4: CloseAndReopen**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long BTCUSDT @ 50000 (Ğ² Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¼ Ğ¼Ğ¸Ğ½ÑƒÑĞµ)
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long @ 49500 (Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ñ…Ğ¾Ğ´)
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:
  1. Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ
  2. Ğ¤Ğ¸ĞºÑĞ¸Ñ€ÑƒĞµĞ¼ P&L
  3. ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñƒ
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 5: Reverse (Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ»)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long BTCUSDT @ 50000
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Short @ 49000
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ (Ğ¿Ñ€Ğ¸ OppositeSignalHandling.Reverse):
  1. Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Long Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
  2. ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Short Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

```json
{
  "SignalBot": {
    "DuplicateHandling": {
      "SameDirection": "Ignore",
      "OppositeDirection": "Ignore",
      "MaxPositionsPerSymbol": 1,
      "MinTimeBetweenDuplicates": "00:05:00",
      "AllowDuplicateOnPartialClose": true
    }
  }
}
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº

```csharp
public record DuplicateHandlingSettings
{
    /// <summary>
    /// Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ» ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ² Ñ‚Ğ¾Ğ¼ Ğ¶Ğµ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸
    /// </summary>
    public DuplicateSignalHandling SameDirection { get; init; } = DuplicateSignalHandling.Ignore;

    /// <summary>
    /// Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ» ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ² Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸
    /// </summary>
    public OppositeSignalHandling OppositeDirection { get; init; } = OppositeSignalHandling.Ignore;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ (Ğ´Ğ»Ñ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğ° OpenNew)
    /// </summary>
    public int MaxPositionsPerSymbol { get; init; } = 1;

    /// <summary>
    /// ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ°Ğ¼Ğ¸
    /// </summary>
    public TimeSpan MinTimeBetweenDuplicates { get; init; } = TimeSpan.FromMinutes(5);

    /// <summary>
    /// Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚ ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ° (Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚Ñ‹ targets)
    /// </summary>
    public bool AllowDuplicateOnPartialClose { get; init; } = true;
}
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ² SignalProcessor

```csharp
public class SignalProcessor
{
    private readonly DuplicateHandlingSettings _duplicateSettings;
    private readonly IPositionStore _positionStore;

    public async Task<SignalProcessingResult> ProcessSignalAsync(
        TradingSignal signal,
        CancellationToken ct = default)
    {
        // 1. ĞĞ°Ğ¹Ñ‚Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ
        var existingPositions = await _positionStore.GetOpenPositionsBySymbolAsync(signal.Symbol, ct);

        if (!existingPositions.Any())
        {
            // ĞĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ - Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°
            return await ExecuteNewSignalAsync(signal, ct);
        }

        // 2. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
        var existingDirection = existingPositions.First().Direction;
        bool isSameDirection = existingDirection == signal.Direction;

        if (isSameDirection)
        {
            return await HandleSameDirectionDuplicateAsync(signal, existingPositions, ct);
        }
        else
        {
            return await HandleOppositeDirectionAsync(signal, existingPositions, ct);
        }
    }

    private async Task<SignalProcessingResult> HandleSameDirectionDuplicateAsync(
        TradingSignal signal,
        IReadOnlyList<SignalPosition> existingPositions,
        CancellationToken ct)
    {
        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»
        var lastPosition = existingPositions.OrderByDescending(p => p.CreatedAt).First();
        var timeSinceLastSignal = DateTime.UtcNow - lastPosition.CreatedAt;

        if (timeSinceLastSignal < _duplicateSettings.MinTimeBetweenDuplicates)
        {
            _logger.LogInformation(
                "Signal ignored: too soon after previous ({Elapsed} < {Min})",
                timeSinceLastSignal, _duplicateSettings.MinTimeBetweenDuplicates);
            return SignalProcessingResult.Skipped("Too soon after previous signal");
        }

        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
        bool hasPartialClose = existingPositions.Any(p => p.Status == PositionStatus.PartialClosed);
        if (hasPartialClose && _duplicateSettings.AllowDuplicateOnPartialClose)
        {
            _logger.LogInformation("Allowing duplicate signal due to partial close");
            return await ExecuteNewSignalAsync(signal, ct);
        }

        // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
        return _duplicateSettings.SameDirection switch
        {
            DuplicateSignalHandling.Ignore =>
                SignalProcessingResult.Skipped("Position already open for symbol"),

            DuplicateSignalHandling.OpenNew when existingPositions.Count < _duplicateSettings.MaxPositionsPerSymbol =>
                await ExecuteNewSignalAsync(signal, ct),

            DuplicateSignalHandling.OpenNew =>
                SignalProcessingResult.Skipped($"Max positions ({_duplicateSettings.MaxPositionsPerSymbol}) reached"),

            DuplicateSignalHandling.UpdateTargets =>
                await UpdateExistingPositionAsync(existingPositions.First(), signal, ct),

            DuplicateSignalHandling.CloseAndReopen =>
                await CloseAndReopenAsync(existingPositions, signal, ct),

            _ => throw new ArgumentOutOfRangeException()
        };
    }

    private async Task<SignalProcessingResult> HandleOppositeDirectionAsync(
        TradingSignal signal,
        IReadOnlyList<SignalPosition> existingPositions,
        CancellationToken ct)
    {
        return _duplicateSettings.OppositeDirection switch
        {
            OppositeSignalHandling.Ignore =>
                SignalProcessingResult.Skipped("Opposite position already open"),

            OppositeSignalHandling.CloseOnly =>
                await CloseExistingPositionsAsync(existingPositions, "Opposite signal received", ct),

            OppositeSignalHandling.Reverse =>
                await ReversePositionAsync(existingPositions, signal, ct),

            _ => throw new ArgumentOutOfRangeException()
        };
    }

    private async Task<SignalProcessingResult> UpdateExistingPositionAsync(
        SignalPosition position,
        TradingSignal newSignal,
        CancellationToken ct)
    {
        _logger.LogInformation(
            "Updating existing position {PositionId} with new signal targets",
            position.Id);

        // 1. ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ SL/TP Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        await CancelPositionOrdersAsync(position, ct);

        // 2. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ targets
        var newTargets = CreateTargetLevels(newSignal, position.RemainingQuantity);

        // 3. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        var newSlOrderId = await PlaceStopLossOrderAsync(
            position.Symbol,
            position.Direction,
            position.RemainingQuantity,
            newSignal.AdjustedStopLoss,
            ct);

        var newTpOrderIds = await PlaceTakeProfitOrdersAsync(
            position.Symbol,
            position.Direction,
            newTargets,
            ct);

        // 4. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        var updatedPosition = position with
        {
            CurrentStopLoss = newSignal.AdjustedStopLoss,
            Targets = newTargets,
            StopLossOrderId = newSlOrderId,
            TakeProfitOrderIds = newTpOrderIds
        };

        await _positionStore.SavePositionAsync(updatedPosition, ct);

        return SignalProcessingResult.Success(updatedPosition, "Targets updated");
    }
}
```

---

## ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸

### Ğ ĞµĞ¶Ğ¸Ğ¼Ñ‹ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°

```csharp
public enum PositionSizingMode
{
    /// <summary>
    /// ĞŸÑ€Ğ¾Ñ†ĞµĞ½Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ´ Ñ€Ğ¸ÑĞº (Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ SL)
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: 1% Ñ€Ğ¸ÑĞºĞ° Ğ¿Ñ€Ğ¸ SL -5% = Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ 20% Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
    /// </summary>
    RiskPercent,

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ° Ğ² quote currency (USDT)
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ²ÑĞµĞ³Ğ´Ğ° Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ° $100
    /// </summary>
    FixedAmount,

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ margin Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ leverage
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: margin $50 Ğ¿Ñ€Ğ¸ leverage 10x = Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ $500
    /// </summary>
    FixedMargin,

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ base currency
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ²ÑĞµĞ³Ğ´Ğ° Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ°Ñ‚ÑŒ 0.01 BTC
    /// </summary>
    FixedQuantity
}
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ñ override Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ğ¼

```json
{
  "SignalBot": {
    "PositionSizing": {
      "DefaultMode": "RiskPercent",
      "DefaultRiskPercent": 1.0,
      "DefaultFixedAmount": 100.0,
      "DefaultFixedMargin": 50.0,

      "SymbolOverrides": {
        "BTCUSDT": {
          "Mode": "FixedAmount",
          "FixedAmount": 200.0
        },
        "ETHUSDT": {
          "Mode": "FixedAmount",
          "FixedAmount": 150.0
        },
        "DOGEUSDT": {
          "Mode": "RiskPercent",
          "RiskPercent": 0.5
        },
        "*USDT": {
          "Mode": "FixedAmount",
          "FixedAmount": 50.0
        }
      },

      "Limits": {
        "MinPositionUsdt": 10.0,
        "MaxPositionUsdt": 1000.0,
        "MaxPositionPercent": 25.0,
        "MaxTotalExposurePercent": 80.0
      }
    }
  }
}
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº

```csharp
public record PositionSizingSettings
{
    /// <summary>
    /// Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
    /// </summary>
    public PositionSizingMode DefaultMode { get; init; } = PositionSizingMode.RiskPercent;

    /// <summary>
    /// ĞŸÑ€Ğ¾Ñ†ĞµĞ½Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ´ Ñ€Ğ¸ÑĞº (Ğ´Ğ»Ñ RiskPercent)
    /// </summary>
    public decimal DefaultRiskPercent { get; init; } = 1.0m;

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ° Ğ² USDT (Ğ´Ğ»Ñ FixedAmount)
    /// </summary>
    public decimal DefaultFixedAmount { get; init; } = 100m;

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ margin Ğ² USDT (Ğ´Ğ»Ñ FixedMargin)
    /// </summary>
    public decimal DefaultFixedMargin { get; init; } = 50m;

    /// <summary>
    /// Override Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ğ¼
    /// ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ wildcards: "BTCUSDT", "*USDT", "BTC*"
    /// </summary>
    public Dictionary<string, SymbolSizingOverride> SymbolOverrides { get; init; } = new();

    /// <summary>
    /// Ğ›Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
    /// </summary>
    public PositionLimits Limits { get; init; } = new();
}

public record SymbolSizingOverride
{
    public PositionSizingMode? Mode { get; init; }
    public decimal? RiskPercent { get; init; }
    public decimal? FixedAmount { get; init; }
    public decimal? FixedMargin { get; init; }
    public decimal? FixedQuantity { get; init; }
    public decimal? MaxLeverage { get; init; }
}

public record PositionLimits
{
    /// <summary>
    /// ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ² USDT
    /// </summary>
    public decimal MinPositionUsdt { get; init; } = 10m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ² USDT
    /// </summary>
    public decimal MaxPositionUsdt { get; init; } = 1000m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºĞ°Ğº % Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
    /// </summary>
    public decimal MaxPositionPercent { get; init; } = 25m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ğ°Ñ ÑĞºÑĞ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞºĞ°Ğº % Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
    /// </summary>
    public decimal MaxTotalExposurePercent { get; init; } = 80m;
}
```

### ĞšĞ°Ğ»ÑŒĞºÑƒĞ»ÑÑ‚Ğ¾Ñ€ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸

```csharp
public class PositionSizeCalculator
{
    private readonly PositionSizingSettings _settings;
    private readonly ILogger<PositionSizeCalculator> _logger;

    public PositionSizeResult Calculate(
        string symbol,
        decimal entryPrice,
        decimal stopLoss,
        int leverage,
        decimal accountEquity,
        decimal currentExposure)
    {
        // 1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ´Ğ»Ñ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° (Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ override)
        var symbolSettings = GetSymbolSettings(symbol);

        // 2. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€
        decimal positionValueUsdt = symbolSettings.Mode switch
        {
            PositionSizingMode.RiskPercent =>
                CalculateFromRisk(accountEquity, symbolSettings.RiskPercent, entryPrice, stopLoss),

            PositionSizingMode.FixedAmount =>
                symbolSettings.FixedAmount,

            PositionSizingMode.FixedMargin =>
                symbolSettings.FixedMargin * leverage,

            PositionSizingMode.FixedQuantity =>
                symbolSettings.FixedQuantity * entryPrice,

            _ => throw new ArgumentOutOfRangeException()
        };

        // 3. ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹
        var (adjustedValue, warnings) = ApplyLimits(
            positionValueUsdt,
            accountEquity,
            currentExposure);

        // 4. ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾
        decimal quantity = adjustedValue / entryPrice;

        return new PositionSizeResult
        {
            Quantity = quantity,
            PositionValueUsdt = adjustedValue,
            RequiredMargin = adjustedValue / leverage,
            RiskAmount = CalculateRiskAmount(adjustedValue, entryPrice, stopLoss),
            Mode = symbolSettings.Mode,
            Warnings = warnings
        };
    }

    private SymbolSizingOverride GetSymbolSettings(string symbol)
    {
        // 1. Ğ¢Ğ¾Ñ‡Ğ½Ğ¾Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ
        if (_settings.SymbolOverrides.TryGetValue(symbol, out var exact))
        {
            return MergeWithDefaults(exact);
        }

        // 2. Wildcard ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ "*USDT", "BTC*")
        foreach (var (pattern, settings) in _settings.SymbolOverrides)
        {
            if (MatchesWildcard(symbol, pattern))
            {
                return MergeWithDefaults(settings);
            }
        }

        // 3. Defaults
        return new SymbolSizingOverride
        {
            Mode = _settings.DefaultMode,
            RiskPercent = _settings.DefaultRiskPercent,
            FixedAmount = _settings.DefaultFixedAmount,
            FixedMargin = _settings.DefaultFixedMargin
        };
    }

    private decimal CalculateFromRisk(
        decimal equity,
        decimal riskPercent,
        decimal entry,
        decimal stopLoss)
    {
        decimal riskAmount = equity * (riskPercent / 100m);
        decimal slDistance = Math.Abs(entry - stopLoss) / entry;

        if (slDistance <= 0)
        {
            _logger.LogWarning("Invalid SL distance, using default position size");
            return _settings.DefaultFixedAmount;
        }

        return riskAmount / slDistance;
    }

    private (decimal Value, List<string> Warnings) ApplyLimits(
        decimal positionValue,
        decimal equity,
        decimal currentExposure)
    {
        var warnings = new List<string>();
        var limits = _settings.Limits;
        decimal adjusted = positionValue;

        // ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼
        if (adjusted < limits.MinPositionUsdt)
        {
            warnings.Add($"Position below minimum ({adjusted:F2} < {limits.MinPositionUsdt}), adjusted up");
            adjusted = limits.MinPositionUsdt;
        }

        // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğ¹
        if (adjusted > limits.MaxPositionUsdt)
        {
            warnings.Add($"Position exceeds max ({adjusted:F2} > {limits.MaxPositionUsdt}), capped");
            adjusted = limits.MaxPositionUsdt;
        }

        // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ ĞºĞ°Ğº % Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
        decimal maxByPercent = equity * (limits.MaxPositionPercent / 100m);
        if (adjusted > maxByPercent)
        {
            warnings.Add($"Position exceeds {limits.MaxPositionPercent}% of equity, capped to {maxByPercent:F2}");
            adjusted = maxByPercent;
        }

        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¾Ğ±Ñ‰ĞµĞ¹ ÑĞºÑĞ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
        decimal maxExposure = equity * (limits.MaxTotalExposurePercent / 100m);
        decimal remainingExposure = maxExposure - currentExposure;

        if (adjusted > remainingExposure)
        {
            warnings.Add($"Total exposure limit reached, reduced to {remainingExposure:F2}");
            adjusted = Math.Max(0, remainingExposure);
        }

        return (adjusted, warnings);
    }

    private bool MatchesWildcard(string symbol, string pattern)
    {
        if (pattern.StartsWith("*"))
            return symbol.EndsWith(pattern.TrimStart('*'));

        if (pattern.EndsWith("*"))
            return symbol.StartsWith(pattern.TrimEnd('*'));

        return false;
    }
}

public record PositionSizeResult
{
    public decimal Quantity { get; init; }
    public decimal PositionValueUsdt { get; init; }
    public decimal RequiredMargin { get; init; }
    public decimal RiskAmount { get; init; }
    public PositionSizingMode Mode { get; init; }
    public IReadOnlyList<string> Warnings { get; init; } = [];
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ°

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 1: RiskPercent**
```
ĞšĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»: $10,000
RiskPercent: 1% ($100 Ñ€Ğ¸ÑĞºĞ°)
Entry: $50,000 (BTC)
Stop Loss: $48,000 (4% Ğ¾Ñ‚ entry)
Ğ Ğ°ÑÑ‡Ñ‘Ñ‚: $100 / 0.04 = $2,500 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: $2,500 / $50,000 = 0.05 BTC
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 2: FixedAmount**
```
FixedAmount: $200
Entry: $50,000
ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: $200 / $50,000 = 0.004 BTC
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 3: FixedMargin**
```
FixedMargin: $50
Leverage: 10x
ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ: $50 * 10 = $500
Entry: $50,000
ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: $500 / $50,000 = 0.01 BTC
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 4: Symbol Override**
```
Config: BTCUSDT.FixedAmount = $200
        Default.FixedAmount = $100

Signal: BTCUSDT â†’ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ $200
Signal: ETHUSDT â†’ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ $100 (default)
```

---

## TODO / Ğ‘ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ

- [ ] ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹)
- [ ] Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ğ¼ (whitelist/blacklist)
- [ ] ĞÑ‚Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ²Ñ…Ğ¾Ğ´ (Limit order Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Market)
- [ ] Trailing stop Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ target
- [ ] Dashboard Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° (web UI)
- [ ] Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼ (ĞºĞ°ĞºĞ¾Ğ¹ ĞºĞ°Ğ½Ğ°Ğ» Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ğ»ÑŒĞ½ĞµĞµ)
- [ ] Backtest ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¸Ğ· Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ ĞºĞ°Ğ½Ğ°Ğ»Ğ°
- [ ] Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Discord
- [ ] ĞœĞ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ push-ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ

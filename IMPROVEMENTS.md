# Trading Bot ‚Äî Roadmap —É–ª—É—á—à–µ–Ω–∏–π

> –î–æ–∫—É–º–µ–Ω—Ç —Å–æ—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–≤—å—é –∫–æ–¥–æ–≤–æ–π –±–∞–∑—ã —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –æ–ø—ã—Ç–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞.
> –î–∞—Ç–∞: 2026-01-01

## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ

1. [–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ](#—Ç–µ–∫—É—â–µ–µ-—Å–æ—Å—Ç–æ—è–Ω–∏–µ)
2. [–§–∞–∑–∞ 1: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è](#—Ñ–∞–∑–∞-1-–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ-—É–ª—É—á—à–µ–Ω–∏—è-–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ-–¥–æ-live)
3. [–§–∞–∑–∞ 2: –û–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å](#—Ñ–∞–∑–∞-2-–æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è-–Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å)
4. [–§–∞–∑–∞ 3: –£–ª—É—á—à–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏](#—Ñ–∞–∑–∞-3-—É–ª—É—á—à–µ–Ω–∏–µ-—Å—Ç—Ä–∞—Ç–µ–≥–∏–∏)
5. [–§–∞–∑–∞ 4: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ñ–∏—á–∏](#—Ñ–∞–∑–∞-4-–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Ñ–∏—á–∏)
6. [–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π –ø–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π](#–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π-–ø–ª–∞–Ω-–¥–µ–π—Å—Ç–≤–∏–π)

---

## –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- **–°—Ç—Ä–∞—Ç–µ–≥–∏—è**: ADX Trend Following —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º —á–µ—Ä–µ–∑ EMA, MACD, OBV, Volume
- **Risk Management**: Drawdown-adjusted sizing (–ø—Ä–∞–≤–∏–ª–æ –î–∂–µ—Ä—Ä–∏ –ü–∞—Ä–∫–µ—Ä–∞)
- **–ë—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥**: Walk-Forward Analysis, Monte Carlo, Parameter Optimization
- **–¢–æ—Ä–≥–æ–≤–ª—è**: Spot Binance (testnet/mainnet), Paper Trading

### –°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã
- ‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∫–æ–¥–∞
- ‚úÖ Research-backed –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (ADX 25, Volume 1.5x, EMA 20/50)
- ‚úÖ Sophisticated risk management —Å portfolio heat tracking
- ‚úÖ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –±—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥ —Å OOS –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π

### –¢–µ–∫—É—â–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
- ‚ùå –ù–µ—Ç –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –ø–æ—Ç–µ—Ä—å
- ‚ùå –¢–æ–ª—å–∫–æ –º–∞—Ä–∫–µ—Ç –æ—Ä–¥–µ—Ä–∞ (–±–æ–ª—å—à–æ–π slippage)
- ‚ùå –ù–µ—Ç persistence —Å–æ—Å—Ç–æ—è–Ω–∏—è
- ‚ùå –ù–µ—Ç –∂—É—Ä–Ω–∞–ª–∞ —Å–¥–µ–ª–æ–∫
- ‚ùå –ù–µ—Ç unit tests

---

## –§–∞–∑–∞ 1: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–æ live)

### 1.1 –î–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –ø–æ—Ç–µ—Ä—å

**–ü—Ä–æ–±–ª–µ–º–∞**: –°–µ–π—á–∞—Å –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –æ–±—â–∏–π circuit breaker –Ω–∞ 20% drawdown. –ó–∞ –æ–¥–∏–Ω –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ã–π –¥–µ–Ω—å –º–æ–∂–Ω–æ –ø–æ—Ç–µ—Ä—è—Ç—å –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—É—é —á–∞—Å—Ç—å –∫–∞–ø–∏—Ç–∞–ª–∞.

**–†–µ—à–µ–Ω–∏–µ**: –î–æ–±–∞–≤–∏—Ç—å `MaxDailyDrawdownPercent` –≤ `RiskSettings`.

**–§–∞–π–ª—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è**:
- `ComplexBot/Services/RiskManagement/RiskManager.cs`
- `ComplexBot/Models/Models.cs`

**–ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

```csharp
// –í RiskSettings –¥–æ–±–∞–≤–∏—Ç—å:
public record RiskSettings
{
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è ...
    public decimal MaxDailyDrawdownPercent { get; init; } = 3m; // 3% –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç
}

// –í RiskManager –¥–æ–±–∞–≤–∏—Ç—å:
private decimal _dayStartEquity;
private DateTime _currentTradingDay;

public void ResetDailyTracking()
{
    var today = DateTime.UtcNow.Date;
    if (_currentTradingDay != today)
    {
        _dayStartEquity = _currentEquity;
        _currentTradingDay = today;
    }
}

public decimal GetDailyDrawdownPercent()
{
    ResetDailyTracking();
    if (_dayStartEquity <= 0) return 0;
    return (_dayStartEquity - _currentEquity) / _dayStartEquity * 100;
}

public bool IsDailyLimitExceeded()
{
    return GetDailyDrawdownPercent() >= _settings.MaxDailyDrawdownPercent;
}

// –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å CanOpenPosition():
public bool CanOpenPosition()
{
    if (IsDailyLimitExceeded())
    {
        Console.WriteLine($"‚õî Daily loss limit exceeded: {GetDailyDrawdownPercent():F2}%");
        return false;
    }
    // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ...
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**:
1. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å `MaxDailyDrawdownPercent = 1%`
2. –í—ã–ø–æ–ª–Ω–∏—Ç—å —Å–µ—Ä–∏—é —É–±—ã—Ç–æ—á–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –Ω–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π –ø–æ—Å–ª–µ –ø—Ä–µ–≤—ã—à–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞
4. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–±—Ä–æ—Å —Å—á—ë—Ç—á–∏–∫–∞ –≤ –ø–æ–ª–Ω–æ—á—å UTC

---

### 1.2 –ñ—É—Ä–Ω–∞–ª —Å–¥–µ–ª–æ–∫ (Trade Journal CSV Export)

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ª–æ–≥–∞ —Å–¥–µ–ª–æ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞. –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–Ω—è—Ç—å –∫–∞–∫–∏–µ —Ñ–∏–ª—å—Ç—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç –ª—É—á—à–µ.

**–†–µ—à–µ–Ω–∏–µ**: –°–æ–∑–¥–∞—Ç—å `TradeJournal` —Å–µ—Ä–≤–∏—Å —Å —ç–∫—Å–ø–æ—Ä—Ç–æ–º –≤ CSV.

**–§–∞–π–ª—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è/–∏–∑–º–µ–Ω–µ–Ω–∏—è**:
- `ComplexBot/Services/Analytics/TradeJournal.cs` (–Ω–æ–≤—ã–π)
- `ComplexBot/Models/Models.cs`

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞–ø–∏—Å–∏ –∂—É—Ä–Ω–∞–ª–∞**:

```csharp
public record TradeJournalEntry
{
    public int TradeId { get; init; }
    public DateTime EntryTime { get; init; }
    public DateTime? ExitTime { get; init; }
    public string Symbol { get; init; } = "";
    public SignalType Direction { get; init; }  // Buy/Sell

    // –¶–µ–Ω—ã
    public decimal EntryPrice { get; init; }
    public decimal? ExitPrice { get; init; }
    public decimal StopLoss { get; init; }
    public decimal TakeProfit { get; init; }

    // –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
    public decimal Quantity { get; init; }
    public decimal PositionValueUsd { get; init; }
    public decimal RiskAmount { get; init; }

    // –†–µ–∑—É–ª—å—Ç–∞—Ç
    public decimal? GrossPnL { get; init; }
    public decimal? NetPnL { get; init; }  // –ü–æ—Å–ª–µ –∫–æ–º–∏—Å—Å–∏–π
    public decimal? RMultiple { get; init; }  // PnL / RiskAmount
    public TradeResult? Result { get; init; }  // Win/Loss/Breakeven

    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –Ω–∞ –º–æ–º–µ–Ω—Ç –≤—Ö–æ–¥–∞
    public decimal AdxValue { get; init; }
    public decimal PlusDi { get; init; }
    public decimal MinusDi { get; init; }
    public decimal FastEma { get; init; }
    public decimal SlowEma { get; init; }
    public decimal Atr { get; init; }
    public decimal MacdHistogram { get; init; }
    public decimal VolumeRatio { get; init; }  // CurrentVol / AvgVol
    public decimal ObvSlope { get; init; }

    // –ü—Ä–∏—á–∏–Ω—ã –≤—Ö–æ–¥–∞/–≤—ã—Ö–æ–¥–∞
    public string EntryReason { get; init; } = "";
    public string ExitReason { get; init; } = "";

    // –í—Ä–µ–º—è –≤ —Å–¥–µ–ª–∫–µ
    public int BarsInTrade { get; init; }
    public TimeSpan? Duration { get; init; }

    // MAE/MFE (Maximum Adverse/Favorable Excursion)
    public decimal? MaxAdverseExcursion { get; init; }  // –•—É–¥—à–∞—è —Ç–æ—á–∫–∞
    public decimal? MaxFavorableExcursion { get; init; }  // –õ—É—á—à–∞—è —Ç–æ—á–∫–∞
}

public enum TradeResult { Win, Loss, Breakeven }
```

**–ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–∞**:

```csharp
public class TradeJournal
{
    private readonly List<TradeJournalEntry> _entries = new();
    private readonly string _outputPath;
    private int _nextTradeId = 1;

    public TradeJournal(string outputPath = "trades")
    {
        _outputPath = outputPath;
        Directory.CreateDirectory(_outputPath);
    }

    public int OpenTrade(TradeJournalEntry entry)
    {
        var tradeId = _nextTradeId++;
        _entries.Add(entry with { TradeId = tradeId });
        return tradeId;
    }

    public void CloseTrade(int tradeId, TradeJournalEntry updates)
    {
        var index = _entries.FindIndex(e => e.TradeId == tradeId);
        if (index >= 0)
        {
            _entries[index] = _entries[index] with
            {
                ExitTime = updates.ExitTime,
                ExitPrice = updates.ExitPrice,
                GrossPnL = updates.GrossPnL,
                NetPnL = updates.NetPnL,
                RMultiple = updates.RMultiple,
                Result = updates.Result,
                ExitReason = updates.ExitReason,
                BarsInTrade = updates.BarsInTrade,
                Duration = updates.Duration,
                MaxAdverseExcursion = updates.MaxAdverseExcursion,
                MaxFavorableExcursion = updates.MaxFavorableExcursion
            };
        }
    }

    public void ExportToCsv(string? filename = null)
    {
        filename ??= $"trades_{DateTime.UtcNow:yyyyMMdd_HHmmss}.csv";
        var path = Path.Combine(_outputPath, filename);

        using var writer = new StreamWriter(path);

        // Header
        writer.WriteLine("TradeId,EntryTime,ExitTime,Symbol,Direction," +
            "EntryPrice,ExitPrice,StopLoss,TakeProfit," +
            "Quantity,PositionValue,RiskAmount," +
            "GrossPnL,NetPnL,RMultiple,Result," +
            "ADX,+DI,-DI,FastEMA,SlowEMA,ATR,MACD_Hist,VolumeRatio,OBV_Slope," +
            "EntryReason,ExitReason,BarsInTrade,Duration,MAE,MFE");

        foreach (var e in _entries)
        {
            writer.WriteLine($"{e.TradeId},{e.EntryTime:O},{e.ExitTime:O},{e.Symbol},{e.Direction}," +
                $"{e.EntryPrice},{e.ExitPrice},{e.StopLoss},{e.TakeProfit}," +
                $"{e.Quantity},{e.PositionValueUsd},{e.RiskAmount}," +
                $"{e.GrossPnL},{e.NetPnL},{e.RMultiple},{e.Result}," +
                $"{e.AdxValue},{e.PlusDi},{e.MinusDi},{e.FastEma},{e.SlowEma},{e.Atr},{e.MacdHistogram},{e.VolumeRatio},{e.ObvSlope}," +
                $"\"{e.EntryReason}\",\"{e.ExitReason}\",{e.BarsInTrade},{e.Duration?.TotalHours:F1}h,{e.MaxAdverseExcursion},{e.MaxFavorableExcursion}");
        }

        Console.WriteLine($"üìä Trade journal exported: {path}");
    }

    public TradeJournalStats GetStats()
    {
        var closed = _entries.Where(e => e.ExitTime.HasValue).ToList();
        var wins = closed.Count(e => e.Result == TradeResult.Win);
        var losses = closed.Count(e => e.Result == TradeResult.Loss);

        return new TradeJournalStats
        {
            TotalTrades = closed.Count,
            WinRate = closed.Count > 0 ? (decimal)wins / closed.Count * 100 : 0,
            AverageRMultiple = closed.Average(e => e.RMultiple ?? 0),
            TotalNetPnL = closed.Sum(e => e.NetPnL ?? 0),
            AverageWin = closed.Where(e => e.Result == TradeResult.Win).Average(e => e.NetPnL ?? 0),
            AverageLoss = closed.Where(e => e.Result == TradeResult.Loss).Average(e => e.NetPnL ?? 0),
            LargestWin = closed.Max(e => e.NetPnL ?? 0),
            LargestLoss = closed.Min(e => e.NetPnL ?? 0),
            AverageBarsInTrade = closed.Average(e => e.BarsInTrade)
        };
    }
}

public record TradeJournalStats
{
    public int TotalTrades { get; init; }
    public decimal WinRate { get; init; }
    public decimal AverageRMultiple { get; init; }
    public decimal TotalNetPnL { get; init; }
    public decimal AverageWin { get; init; }
    public decimal AverageLoss { get; init; }
    public decimal LargestWin { get; init; }
    public decimal LargestLoss { get; init; }
    public double AverageBarsInTrade { get; init; }
}
```

**–ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è**:

```csharp
var journal = new TradeJournal("./trade_logs");

// –ü—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Å–¥–µ–ª–∫–∏
var tradeId = journal.OpenTrade(new TradeJournalEntry
{
    EntryTime = DateTime.UtcNow,
    Symbol = "BTCUSDT",
    Direction = SignalType.Buy,
    EntryPrice = 45000m,
    StopLoss = 43500m,
    TakeProfit = 47250m,
    Quantity = 0.1m,
    PositionValueUsd = 4500m,
    RiskAmount = 150m,
    AdxValue = 28.5m,
    // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    EntryReason = "ADX>25, EMA cross, Volume spike 1.8x"
});

// –ü—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–¥–µ–ª–∫–∏
journal.CloseTrade(tradeId, new TradeJournalEntry
{
    ExitTime = DateTime.UtcNow,
    ExitPrice = 46500m,
    GrossPnL = 150m,
    NetPnL = 141m,
    RMultiple = 1.0m,
    Result = TradeResult.Win,
    ExitReason = "Take profit hit",
    BarsInTrade = 12,
    MaxAdverseExcursion = -75m,
    MaxFavorableExcursion = 200m
});

// –≠–∫—Å–ø–æ—Ä—Ç
journal.ExportToCsv();
var stats = journal.GetStats();
Console.WriteLine($"Win Rate: {stats.WinRate:F1}%, Avg R: {stats.AverageRMultiple:F2}");
```

---

### 1.3 –ë–∏—Ä–∂–µ–≤—ã–µ —Å—Ç–æ–ø-–æ—Ä–¥–µ—Ä–∞ (Exchange-Side Stop Orders)

**–ü—Ä–æ–±–ª–µ–º–∞**: –°–µ–π—á–∞—Å —Å—Ç–æ–ø—ã –ø—Ä–æ–≥—Ä–∞–º–º–Ω—ã–µ ‚Äî –µ—Å–ª–∏ –±–æ—Ç –æ—Ç–∫–ª—é—á–∏—Ç—Å—è, –ø–æ–∑–∏—Ü–∏—è –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –±–µ–∑ –∑–∞—â–∏—Ç—ã.

**–†–µ—à–µ–Ω–∏–µ**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å OCO (One-Cancels-Other) –æ—Ä–¥–µ—Ä–∞ Binance.

**–§–∞–π–ª—ã –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è**:
- `ComplexBot/Services/Trading/BinanceLiveTrader.cs`

**–ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

```csharp
public async Task<bool> PlaceOcoOrder(
    string symbol,
    OrderSide side,
    decimal quantity,
    decimal stopLossPrice,
    decimal stopLossLimitPrice,
    decimal takeProfitPrice)
{
    try
    {
        // OCO –æ—Ä–¥–µ—Ä: —Å—Ç–æ–ø-–ª–æ—Å—Å + —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç, –æ–¥–∏–Ω –æ—Ç–º–µ–Ω—è–µ—Ç –¥—Ä—É–≥–æ–π
        var result = await _client.SpotApi.Trading.PlaceOcoOrderAsync(
            symbol: symbol,
            side: side,
            quantity: quantity,
            price: takeProfitPrice,           // Limit order (take profit)
            stopPrice: stopLossPrice,          // Stop trigger price
            stopLimitPrice: stopLossLimitPrice, // Stop limit price
            stopLimitTimeInForce: TimeInForce.GoodTillCanceled
        );

        if (result.Success)
        {
            Console.WriteLine($"‚úÖ OCO Order placed:");
            Console.WriteLine($"   Take Profit: {takeProfitPrice}");
            Console.WriteLine($"   Stop Loss: {stopLossPrice} (limit: {stopLossLimitPrice})");
            Console.WriteLine($"   Order List ID: {result.Data.OrderListId}");
            return true;
        }
        else
        {
            Console.WriteLine($"‚ùå OCO Order failed: {result.Error?.Message}");
            return false;
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"‚ùå OCO Order exception: {ex.Message}");
        return false;
    }
}

// –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –≤—Ö–æ–¥–∞ –≤ –ø–æ–∑–∏—Ü–∏—é:
public async Task<bool> EnterPosition(TradeSignal signal)
{
    // 1. –û—Ç–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é –º–∞—Ä–∫–µ—Ç –æ—Ä–¥–µ—Ä–æ–º
    var marketOrder = await PlaceMarketOrder(signal.Symbol,
        signal.Type == SignalType.Buy ? OrderSide.Buy : OrderSide.Sell,
        _positionQuantity);

    if (!marketOrder) return false;

    // 2. –°—Ä–∞–∑—É –≤—ã—Å—Ç–∞–≤–∏—Ç—å OCO –¥–ª—è –∑–∞—â–∏—Ç—ã
    var exitSide = signal.Type == SignalType.Buy ? OrderSide.Sell : OrderSide.Buy;
    var stopLimitPrice = signal.StopLoss!.Value * (signal.Type == SignalType.Buy ? 0.995m : 1.005m);

    await PlaceOcoOrder(
        signal.Symbol,
        exitSide,
        _positionQuantity,
        signal.StopLoss!.Value,
        stopLimitPrice,
        signal.TakeProfit!.Value
    );

    return true;
}
```

**–í–∞–∂–Ω–æ**: –ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ trailing stop –Ω—É–∂–Ω–æ –æ—Ç–º–µ–Ω—è—Ç—å —Å—Ç–∞—Ä—ã–π OCO –∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–π.

```csharp
public async Task UpdateTrailingStop(string symbol, decimal newStopPrice, decimal takeProfitPrice)
{
    // 1. –û—Ç–º–µ–Ω–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π OCO
    await CancelOcoOrder(symbol, _currentOcoOrderListId);

    // 2. –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Å –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–º —Å—Ç–æ–ø–æ–º
    var stopLimitPrice = newStopPrice * 0.995m; // 0.5% –Ω–∏–∂–µ –¥–ª—è –ª–æ–Ω–≥–∞
    await PlaceOcoOrder(symbol, OrderSide.Sell, _positionQuantity,
        newStopPrice, stopLimitPrice, takeProfitPrice);
}
```

---

### 1.4 Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ —Å–¥–µ–ª–∫–∞—Ö –∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–æ–±—ã—Ç–∏—è—Ö.

**–†–µ—à–µ–Ω–∏–µ**: –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å Telegram Bot API.

**–§–∞–π–ª—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è**:
- `ComplexBot/Services/Notifications/TelegramNotifier.cs`

**NuGet –ø–∞–∫–µ—Ç**: `Telegram.Bot`

**–ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

```csharp
using Telegram.Bot;
using Telegram.Bot.Types.Enums;

public class TelegramNotifier
{
    private readonly TelegramBotClient _bot;
    private readonly long _chatId;
    private readonly bool _enabled;

    public TelegramNotifier(string? botToken, long chatId)
    {
        _enabled = !string.IsNullOrEmpty(botToken);
        if (_enabled)
        {
            _bot = new TelegramBotClient(botToken!);
            _chatId = chatId;
        }
    }

    public async Task SendTradeOpen(TradeSignal signal, decimal quantity, decimal riskAmount)
    {
        if (!_enabled) return;

        var emoji = signal.Type == SignalType.Buy ? "üü¢" : "üî¥";
        var direction = signal.Type == SignalType.Buy ? "LONG" : "SHORT";

        var message = $"""
            {emoji} *NEW TRADE OPENED*

            *{signal.Symbol}* {direction}

            üìç Entry: `{signal.Price:F2}`
            üõë Stop Loss: `{signal.StopLoss:F2}`
            üéØ Take Profit: `{signal.TakeProfit:F2}`

            üìä Size: `{quantity:F4}`
            üí∞ Risk: `${riskAmount:F2}`

            üìù _{signal.Reason}_
            """;

        await SendMessage(message);
    }

    public async Task SendTradeClose(string symbol, decimal entryPrice, decimal exitPrice,
        decimal pnl, decimal rMultiple, string reason)
    {
        if (!_enabled) return;

        var emoji = pnl >= 0 ? "‚úÖ" : "‚ùå";
        var pnlEmoji = pnl >= 0 ? "üìà" : "üìâ";

        var message = $"""
            {emoji} *TRADE CLOSED*

            *{symbol}*

            üìç Entry: `{entryPrice:F2}`
            üìç Exit: `{exitPrice:F2}`

            {pnlEmoji} PnL: `${pnl:F2}` ({rMultiple:F2}R)

            üìù _{reason}_
            """;

        await SendMessage(message);
    }

    public async Task SendDrawdownAlert(decimal currentDrawdown, decimal dailyDrawdown)
    {
        if (!_enabled) return;

        var message = $"""
            ‚ö†Ô∏è *DRAWDOWN ALERT*

            üìâ Total Drawdown: `{currentDrawdown:F2}%`
            üìâ Daily Drawdown: `{dailyDrawdown:F2}%`

            _Risk management may reduce position sizes_
            """;

        await SendMessage(message);
    }

    public async Task SendCircuitBreakerTriggered(string reason)
    {
        if (!_enabled) return;

        var message = $"""
            üö® *CIRCUIT BREAKER TRIGGERED*

            ‚õî Trading has been stopped!

            Reason: _{reason}_

            _Manual intervention required_
            """;

        await SendMessage(message);
    }

    public async Task SendDailySummary(TradeJournalStats stats, decimal equity, decimal drawdown)
    {
        if (!_enabled) return;

        var message = $"""
            üìä *DAILY SUMMARY*

            üí∞ Equity: `${equity:F2}`
            üìâ Drawdown: `{drawdown:F2}%`

            üìà Trades Today: `{stats.TotalTrades}`
            üéØ Win Rate: `{stats.WinRate:F1}%`
            üíµ Net PnL: `${stats.TotalNetPnL:F2}`

            Best Trade: `${stats.LargestWin:F2}`
            Worst Trade: `${stats.LargestLoss:F2}`
            """;

        await SendMessage(message);
    }

    private async Task SendMessage(string message)
    {
        try
        {
            await _bot.SendTextMessageAsync(
                chatId: _chatId,
                text: message,
                parseMode: ParseMode.Markdown
            );
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Telegram error: {ex.Message}");
        }
    }
}
```

**–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è**:

```csharp
// –í appsettings.json –∏–ª–∏ environment variables:
{
    "Telegram": {
        "BotToken": "123456789:ABCdefGHIjklMNOpqrsTUVwxyz",
        "ChatId": -1001234567890
    }
}

// –ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å:
// 1. –°–æ–∑–¥–∞—Ç—å –±–æ—Ç–∞ —á–µ—Ä–µ–∑ @BotFather –≤ Telegram
// 2. –ü–æ–ª—É—á–∏—Ç—å token
// 3. –î–æ–±–∞–≤–∏—Ç—å –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø—É –∏–ª–∏ –Ω–∞–ø–∏—Å–∞—Ç—å –µ–º—É /start
// 4. –ü–æ–ª—É—á–∏—Ç—å chat_id —á–µ—Ä–µ–∑ https://api.telegram.org/bot<TOKEN>/getUpdates
```

---

### 1.5 –†–µ–∞–ª—Ç–∞–π–º equity tracking

**–ü—Ä–æ–±–ª–µ–º–∞**: Equity –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–¥–µ–ª–∫–∏. –ù–µ—Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π P&L –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è.

**–†–µ—à–µ–Ω–∏–µ**: –î–æ–±–∞–≤–∏—Ç—å floating P&L –≤ RiskManager.

**–ü—Ä–∏–º–µ—Ä —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏**:

```csharp
public class RiskManager
{
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ ...

    private readonly Dictionary<string, OpenPosition> _openPositions = new();

    public record OpenPosition
    {
        public string Symbol { get; init; } = "";
        public SignalType Direction { get; init; }
        public decimal EntryPrice { get; init; }
        public decimal Quantity { get; init; }
        public decimal StopLoss { get; init; }
        public decimal CurrentPrice { get; set; }
    }

    public void UpdatePositionPrice(string symbol, decimal currentPrice)
    {
        if (_openPositions.TryGetValue(symbol, out var position))
        {
            position.CurrentPrice = currentPrice;
        }
    }

    public decimal GetUnrealizedPnL()
    {
        decimal total = 0;
        foreach (var pos in _openPositions.Values)
        {
            var pnl = pos.Direction == SignalType.Buy
                ? (pos.CurrentPrice - pos.EntryPrice) * pos.Quantity
                : (pos.EntryPrice - pos.CurrentPrice) * pos.Quantity;
            total += pnl;
        }
        return total;
    }

    public decimal GetTotalEquity()
    {
        return _currentEquity + GetUnrealizedPnL();
    }

    public decimal GetTotalDrawdownPercent()
    {
        var totalEquity = GetTotalEquity();
        if (_peakEquity <= 0) return 0;
        return (_peakEquity - totalEquity) / _peakEquity * 100;
    }

    // –û–±–Ω–æ–≤–ª—ë–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å —É—á—ë—Ç–æ–º floating P&L
    public bool CanOpenPosition()
    {
        var totalDrawdown = GetTotalDrawdownPercent();
        if (totalDrawdown >= _settings.MaxDrawdownPercent)
        {
            Console.WriteLine($"‚õî Max drawdown exceeded (including unrealized): {totalDrawdown:F2}%");
            return false;
        }

        if (IsDailyLimitExceeded())
        {
            return false;
        }

        if (GetPortfolioHeatPercent() >= _settings.MaxPortfolioHeatPercent)
        {
            return false;
        }

        return true;
    }
}
```

---

### 1.6 –í–∞–ª–∏–¥–∞—Ü–∏—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–æ–≤

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–π —Ü–µ–Ω—ã –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è vs –æ–∂–∏–¥–∞–µ–º–æ–π.

**–†–µ—à–µ–Ω–∏–µ**: –î–æ–±–∞–≤–∏—Ç—å slippage validation.

```csharp
public class ExecutionValidator
{
    private readonly decimal _maxSlippagePercent;

    public ExecutionValidator(decimal maxSlippagePercent = 1.0m)
    {
        _maxSlippagePercent = maxSlippagePercent;
    }

    public record ExecutionResult
    {
        public bool IsAcceptable { get; init; }
        public decimal ExpectedPrice { get; init; }
        public decimal ActualPrice { get; init; }
        public decimal SlippagePercent { get; init; }
        public string? RejectReason { get; init; }
    }

    public ExecutionResult ValidateExecution(
        decimal expectedPrice,
        decimal actualPrice,
        OrderSide side)
    {
        var slippage = side == OrderSide.Buy
            ? (actualPrice - expectedPrice) / expectedPrice * 100
            : (expectedPrice - actualPrice) / expectedPrice * 100;

        var isAcceptable = slippage <= _maxSlippagePercent;

        return new ExecutionResult
        {
            IsAcceptable = isAcceptable,
            ExpectedPrice = expectedPrice,
            ActualPrice = actualPrice,
            SlippagePercent = slippage,
            RejectReason = isAcceptable ? null : $"Slippage {slippage:F2}% exceeds max {_maxSlippagePercent}%"
        };
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
var validator = new ExecutionValidator(maxSlippagePercent: 0.5m);

var order = await PlaceMarketOrder(symbol, OrderSide.Buy, quantity);
var validation = validator.ValidateExecution(
    expectedPrice: signal.Price,
    actualPrice: order.AveragePrice,
    side: OrderSide.Buy
);

if (!validation.IsAcceptable)
{
    Console.WriteLine($"‚ö†Ô∏è Bad execution: {validation.RejectReason}");
    // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
    await ClosePosition(symbol);
}
```

---

### 1.7 –õ–∏–º–∏—Ç–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ –¥–ª—è –≤—Ö–æ–¥–∞

**–ü—Ä–æ–±–ª–µ–º–∞**: –ú–∞—Ä–∫–µ—Ç –æ—Ä–¥–µ—Ä–∞ –¥–∞—é—Ç –ø–ª–æ—Ö—É—é —Ü–µ–Ω—É –≤ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏.

**–†–µ—à–µ–Ω–∏–µ**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–∏–º–∏—Ç–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ —Å —Ç–∞–π–º–∞—É—Ç–æ–º.

```csharp
public async Task<OrderResult?> PlaceLimitOrderWithTimeout(
    string symbol,
    OrderSide side,
    decimal quantity,
    decimal limitPrice,
    TimeSpan timeout)
{
    // 1. –†–∞–∑–º–µ—Å—Ç–∏—Ç—å –ª–∏–º–∏—Ç–Ω—ã–π –æ—Ä–¥–µ—Ä
    var order = await _client.SpotApi.Trading.PlaceOrderAsync(
        symbol: symbol,
        side: side,
        type: SpotOrderType.Limit,
        quantity: quantity,
        price: limitPrice,
        timeInForce: TimeInForce.GoodTillCanceled
    );

    if (!order.Success)
    {
        Console.WriteLine($"‚ùå Limit order failed: {order.Error?.Message}");
        return null;
    }

    var orderId = order.Data.Id;
    var startTime = DateTime.UtcNow;

    // 2. –ñ–¥–∞—Ç—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    while (DateTime.UtcNow - startTime < timeout)
    {
        await Task.Delay(1000);

        var status = await _client.SpotApi.Trading.GetOrderAsync(symbol, orderId);
        if (status.Success)
        {
            if (status.Data.Status == OrderStatus.Filled)
            {
                Console.WriteLine($"‚úÖ Limit order filled at {status.Data.AverageFillPrice}");
                return new OrderResult
                {
                    OrderId = orderId,
                    FilledQuantity = status.Data.QuantityFilled,
                    AveragePrice = status.Data.AverageFillPrice ?? limitPrice,
                    Status = OrderStatus.Filled
                };
            }
            else if (status.Data.Status == OrderStatus.PartiallyFilled)
            {
                Console.WriteLine($"‚è≥ Partially filled: {status.Data.QuantityFilled}/{quantity}");
            }
        }
    }

    // 3. –¢–∞–π–º–∞—É—Ç ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å –æ—Ä–¥–µ—Ä
    Console.WriteLine($"‚è∞ Limit order timeout, cancelling...");
    await _client.SpotApi.Trading.CancelOrderAsync(symbol, orderId);

    // 4. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á–∞—Å—Ç–∏—á–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
    var finalStatus = await _client.SpotApi.Trading.GetOrderAsync(symbol, orderId);
    if (finalStatus.Success && finalStatus.Data.QuantityFilled > 0)
    {
        return new OrderResult
        {
            OrderId = orderId,
            FilledQuantity = finalStatus.Data.QuantityFilled,
            AveragePrice = finalStatus.Data.AverageFillPrice ?? limitPrice,
            Status = OrderStatus.PartiallyFilled
        };
    }

    return null;
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å fallback –Ω–∞ –º–∞—Ä–∫–µ—Ç:
public async Task<bool> EnterPositionSmart(TradeSignal signal, decimal quantity)
{
    // –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –ª–∏–º–∏—Ç–Ω—ã–π –æ—Ä–¥–µ—Ä —Å —É–ª—É—á—à–µ–Ω–∏–µ–º —Ü–µ–Ω—ã –Ω–∞ 0.1%
    var limitPrice = signal.Type == SignalType.Buy
        ? signal.Price * 0.999m  // –ß—É—Ç—å –Ω–∏–∂–µ —Ç–µ–∫—É—â–µ–π
        : signal.Price * 1.001m; // –ß—É—Ç—å –≤—ã—à–µ —Ç–µ–∫—É—â–µ–π

    var result = await PlaceLimitOrderWithTimeout(
        signal.Symbol,
        signal.Type == SignalType.Buy ? OrderSide.Buy : OrderSide.Sell,
        quantity,
        limitPrice,
        timeout: TimeSpan.FromSeconds(30)
    );

    if (result?.Status == OrderStatus.Filled)
    {
        return true;
    }

    // Fallback –Ω–∞ –º–∞—Ä–∫–µ—Ç –µ—Å–ª–∏ –ª–∏–º–∏—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
    if (result?.Status == OrderStatus.PartiallyFilled)
    {
        var remaining = quantity - result.FilledQuantity;
        await PlaceMarketOrder(signal.Symbol,
            signal.Type == SignalType.Buy ? OrderSide.Buy : OrderSide.Sell,
            remaining);
    }
    else
    {
        await PlaceMarketOrder(signal.Symbol,
            signal.Type == SignalType.Buy ? OrderSide.Buy : OrderSide.Sell,
            quantity);
    }

    return true;
}
```

---

### 1.8 –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞. –ú–æ–∂–Ω–æ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å —Å –æ–∫–æ–ª–æ–Ω—É–ª–µ–≤—ã–º —Å—á—ë—Ç–æ–º.

**–†–µ—à–µ–Ω–∏–µ**: –î–æ–±–∞–≤–∏—Ç—å `MinimumEquity` –≤ RiskSettings.

```csharp
public record RiskSettings
{
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è ...
    public decimal MinimumEquityUsd { get; init; } = 100m;  // –ú–∏–Ω–∏–º—É–º $100
}

public bool CanOpenPosition()
{
    if (_currentEquity < _settings.MinimumEquityUsd)
    {
        Console.WriteLine($"‚õî Equity below minimum: ${_currentEquity:F2} < ${_settings.MinimumEquityUsd}");
        return false;
    }
    // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ...
}
```

---

### 1.9 –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –ø–æ–∑–∏—Ü–∏–π (Multi-Symbol)

**–ü—Ä–æ–±–ª–µ–º–∞**: –ü—Ä–∏ —Ç–æ—Ä–≥–æ–≤–ª–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –ø–∞—Ä–∞–º–∏ –Ω–µ—Ç –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è.

**–†–µ—à–µ–Ω–∏–µ**: Portfolio-level risk management.

```csharp
public class PortfolioRiskManager
{
    private readonly Dictionary<string, RiskManager> _symbolManagers = new();
    private readonly decimal _maxTotalDrawdownPercent;
    private readonly decimal _maxCorrelatedRiskPercent;

    private decimal _totalPeakEquity;
    private decimal _totalCurrentEquity;

    // –ì—Ä—É–ø–ø—ã –∫–æ—Ä—Ä–µ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∞–∫—Ç–∏–≤–æ–≤
    private readonly Dictionary<string, string[]> _correlationGroups = new()
    {
        ["BTC_CORRELATED"] = new[] { "BTCUSDT", "ETHUSDT", "BNBUSDT" },
        ["ALTCOINS"] = new[] { "SOLUSDT", "ADAUSDT", "DOTUSDT" },
        ["STABLES"] = new[] { "USDCUSDT", "BUSDUSDT" }
    };

    public PortfolioRiskManager(decimal maxTotalDrawdown = 25m, decimal maxCorrelatedRisk = 10m)
    {
        _maxTotalDrawdownPercent = maxTotalDrawdown;
        _maxCorrelatedRiskPercent = maxCorrelatedRisk;
    }

    public decimal GetCorrelatedRisk(string symbol)
    {
        // –ù–∞–π—Ç–∏ –≥—Ä—É–ø–ø—É —Å–∏–º–≤–æ–ª–∞
        var group = _correlationGroups
            .FirstOrDefault(g => g.Value.Contains(symbol));

        if (group.Key == null) return 0;

        // –°—É–º–º–∏—Ä–æ–≤–∞—Ç—å —Ä–∏—Å–∫ –ø–æ –≤—Å–µ–º —Å–∏–º–≤–æ–ª–∞–º –≥—Ä—É–ø–ø—ã
        decimal totalRisk = 0;
        foreach (var correlatedSymbol in group.Value)
        {
            if (_symbolManagers.TryGetValue(correlatedSymbol, out var manager))
            {
                totalRisk += manager.GetPortfolioHeatPercent();
            }
        }

        return totalRisk;
    }

    public bool CanOpenPosition(string symbol)
    {
        // 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±—â–∏–π drawdown –ø–æ—Ä—Ç—Ñ–µ–ª—è
        var totalDrawdown = GetTotalDrawdownPercent();
        if (totalDrawdown >= _maxTotalDrawdownPercent)
        {
            Console.WriteLine($"‚õî Portfolio drawdown exceeded: {totalDrawdown:F2}%");
            return false;
        }

        // 2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω—ã–π —Ä–∏—Å–∫
        var correlatedRisk = GetCorrelatedRisk(symbol);
        if (correlatedRisk >= _maxCorrelatedRiskPercent)
        {
            Console.WriteLine($"‚õî Correlated risk too high for {symbol}: {correlatedRisk:F2}%");
            return false;
        }

        // 3. –î–µ–ª–µ–≥–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É
        if (_symbolManagers.TryGetValue(symbol, out var manager))
        {
            return manager.CanOpenPosition();
        }

        return true;
    }

    public decimal GetTotalDrawdownPercent()
    {
        if (_totalPeakEquity <= 0) return 0;
        return (_totalPeakEquity - _totalCurrentEquity) / _totalPeakEquity * 100;
    }

    public void UpdateEquity(string symbol, decimal equity)
    {
        if (_symbolManagers.TryGetValue(symbol, out var manager))
        {
            // ... update logic
        }

        RecalculateTotalEquity();
    }

    private void RecalculateTotalEquity()
    {
        _totalCurrentEquity = _symbolManagers.Values.Sum(m => m.GetTotalEquity());
        _totalPeakEquity = Math.Max(_totalPeakEquity, _totalCurrentEquity);
    }
}
```

---

## –§–∞–∑–∞ 2: –û–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å

### 2.1 State Persistence (–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è)

**–ü—Ä–æ–±–ª–µ–º–∞**: –ü—Ä–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞ —Ç–µ—Ä—è–µ—Ç—Å—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö.

**–†–µ—à–µ–Ω–∏–µ**: –°–æ—Ö—Ä–∞–Ω—è—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ JSON —Ñ–∞–π–ª.

```csharp
public class StateManager
{
    private readonly string _statePath;

    public record BotState
    {
        public DateTime LastUpdate { get; init; }
        public decimal CurrentEquity { get; init; }
        public decimal PeakEquity { get; init; }
        public List<SavedPosition> OpenPositions { get; init; } = new();
        public List<SavedOcoOrder> ActiveOcoOrders { get; init; } = new();
        public int NextTradeId { get; init; }
    }

    public record SavedPosition
    {
        public string Symbol { get; init; } = "";
        public SignalType Direction { get; init; }
        public decimal EntryPrice { get; init; }
        public decimal Quantity { get; init; }
        public decimal StopLoss { get; init; }
        public decimal TakeProfit { get; init; }
        public DateTime EntryTime { get; init; }
        public int TradeId { get; init; }
    }

    public record SavedOcoOrder
    {
        public string Symbol { get; init; } = "";
        public long OrderListId { get; init; }
    }

    public StateManager(string statePath = "bot_state.json")
    {
        _statePath = statePath;
    }

    public async Task SaveState(BotState state)
    {
        var json = JsonSerializer.Serialize(state, new JsonSerializerOptions
        {
            WriteIndented = true
        });
        await File.WriteAllTextAsync(_statePath, json);
        Console.WriteLine($"üíæ State saved: {state.OpenPositions.Count} positions");
    }

    public async Task<BotState?> LoadState()
    {
        if (!File.Exists(_statePath))
        {
            Console.WriteLine("üìÇ No saved state found, starting fresh");
            return null;
        }

        try
        {
            var json = await File.ReadAllTextAsync(_statePath);
            var state = JsonSerializer.Deserialize<BotState>(json);
            Console.WriteLine($"üìÇ State loaded: {state?.OpenPositions.Count ?? 0} positions");
            return state;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ö†Ô∏è Failed to load state: {ex.Message}");
            return null;
        }
    }

    public async Task ReconcileWithExchange(IBinanceRestClient client, BotState state)
    {
        Console.WriteLine("üîÑ Reconciling state with exchange...");

        foreach (var savedPos in state.OpenPositions)
        {
            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å –Ω–∞ –±–∏—Ä–∂–µ
            var balance = await client.SpotApi.Account.GetBalancesAsync();
            var asset = savedPos.Symbol.Replace("USDT", "");
            var actualBalance = balance.Data.FirstOrDefault(b => b.Asset == asset);

            if (actualBalance?.Available >= savedPos.Quantity * 0.99m)
            {
                Console.WriteLine($"‚úÖ Position confirmed: {savedPos.Symbol} {savedPos.Quantity}");
            }
            else
            {
                Console.WriteLine($"‚ö†Ô∏è Position mismatch: {savedPos.Symbol}");
                Console.WriteLine($"   Expected: {savedPos.Quantity}, Actual: {actualBalance?.Available ?? 0}");
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å OCO –æ—Ä–¥–µ—Ä–∞
        foreach (var oco in state.ActiveOcoOrders)
        {
            var ocoStatus = await client.SpotApi.Trading.GetOcoOrderAsync(
                orderListId: oco.OrderListId);

            if (ocoStatus.Success)
            {
                Console.WriteLine($"‚úÖ OCO order active: {oco.Symbol} #{oco.OrderListId}");
            }
            else
            {
                Console.WriteLine($"‚ö†Ô∏è OCO order not found: {oco.Symbol} #{oco.OrderListId}");
            }
        }
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ:
var stateManager = new StateManager();
var savedState = await stateManager.LoadState();

if (savedState != null)
{
    await stateManager.ReconcileWithExchange(binanceClient, savedState);
    riskManager.RestoreFromState(savedState);
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏:
async Task OnPositionOpened(SavedPosition position)
{
    var state = BuildCurrentState();
    await stateManager.SaveState(state);
}
```

---

### 2.2 Reconnection Logic

**–ü—Ä–æ–±–ª–µ–º–∞**: –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Å–≤—è–∑–∏.

**–†–µ—à–µ–Ω–∏–µ**: Exponential backoff —Å health checks.

```csharp
public class ConnectionManager
{
    private readonly IBinanceSocketClient _socketClient;
    private readonly int[] _backoffDelays = { 1000, 2000, 4000, 8000, 16000, 32000 };
    private int _reconnectAttempt = 0;
    private bool _isConnected = false;

    public event Action? OnConnected;
    public event Action<string>? OnDisconnected;
    public event Action<Exception>? OnError;

    public async Task<bool> ConnectWithRetry(string symbol,
        Action<DataEvent<IBinanceStreamKlineData>> onKline)
    {
        while (_reconnectAttempt < _backoffDelays.Length)
        {
            try
            {
                Console.WriteLine($"üîå Connecting to {symbol} stream (attempt {_reconnectAttempt + 1})...");

                var result = await _socketClient.SpotApi.ExchangeData
                    .SubscribeToKlineUpdatesAsync(
                        symbol,
                        KlineInterval.FourHour,
                        onKline
                    );

                if (result.Success)
                {
                    _isConnected = true;
                    _reconnectAttempt = 0;
                    Console.WriteLine($"‚úÖ Connected to {symbol} stream");
                    OnConnected?.Invoke();

                    // –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—Ç–∫–ª—é—á–µ–Ω–∏—è
                    result.Data.ConnectionLost += () =>
                    {
                        _isConnected = false;
                        OnDisconnected?.Invoke("Connection lost");
                        _ = ReconnectAsync(symbol, onKline);
                    };

                    return true;
                }
                else
                {
                    throw new Exception(result.Error?.Message ?? "Unknown error");
                }
            }
            catch (Exception ex)
            {
                OnError?.Invoke(ex);
                var delay = _backoffDelays[_reconnectAttempt];
                Console.WriteLine($"‚ùå Connection failed: {ex.Message}");
                Console.WriteLine($"‚è≥ Retrying in {delay}ms...");

                await Task.Delay(delay);
                _reconnectAttempt++;
            }
        }

        Console.WriteLine("‚ùå Max reconnection attempts reached");
        return false;
    }

    private async Task ReconnectAsync(string symbol,
        Action<DataEvent<IBinanceStreamKlineData>> onKline)
    {
        Console.WriteLine("üîÑ Attempting to reconnect...");
        await ConnectWithRetry(symbol, onKline);
    }

    public async Task StartHealthCheck(TimeSpan interval)
    {
        while (true)
        {
            await Task.Delay(interval);

            if (!_isConnected)
            {
                Console.WriteLine("üíî Health check: Disconnected");
                // Trigger reconnect logic
            }
            else
            {
                Console.WriteLine("üíö Health check: Connected");
            }
        }
    }
}
```

---

### 2.3 Graceful Shutdown

**–ü—Ä–æ–±–ª–µ–º–∞**: –ü—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –±–æ—Ç–∞ –ø–æ–∑–∏—Ü–∏–∏ –º–æ–≥—É—Ç –æ—Å—Ç–∞—Ç—å—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º–∏ –±–µ–∑ –∑–∞—â–∏—Ç—ã.

**–†–µ—à–µ–Ω–∏–µ**: –û–±—Ä–∞–±–æ—Ç–∫–∞ SIGTERM/SIGINT —Å –æ–ø—Ü–∏–µ–π –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–π.

```csharp
public class GracefulShutdown
{
    private readonly CancellationTokenSource _cts = new();
    private readonly StateManager _stateManager;
    private readonly BinanceLiveTrader _trader;
    private readonly TelegramNotifier? _notifier;

    public GracefulShutdown(StateManager stateManager, BinanceLiveTrader trader,
        TelegramNotifier? notifier = null)
    {
        _stateManager = stateManager;
        _trader = trader;
        _notifier = notifier;

        // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤
        Console.CancelKeyPress += OnCancelKeyPress;
        AppDomain.CurrentDomain.ProcessExit += OnProcessExit;
    }

    public CancellationToken Token => _cts.Token;

    private void OnCancelKeyPress(object? sender, ConsoleCancelEventArgs e)
    {
        e.Cancel = true; // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        _ = ShutdownAsync("Ctrl+C pressed");
    }

    private void OnProcessExit(object? sender, EventArgs e)
    {
        ShutdownAsync("Process exit").Wait(TimeSpan.FromSeconds(30));
    }

    public async Task ShutdownAsync(string reason)
    {
        Console.WriteLine($"\nüõë Initiating graceful shutdown: {reason}");

        // 1. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏—ë–º –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
        _cts.Cancel();

        // 2. –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        Console.WriteLine("üíæ Saving current state...");
        var state = _trader.BuildCurrentState();
        await _stateManager.SaveState(state);

        // 3. –°–ø—Ä–æ—Å–∏—Ç—å –æ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–π (–µ—Å–ª–∏ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º)
        if (state.OpenPositions.Any() && Console.IsInputRedirected == false)
        {
            Console.WriteLine($"\n‚ö†Ô∏è You have {state.OpenPositions.Count} open position(s).");
            Console.WriteLine("Choose action:");
            Console.WriteLine("  1. Keep positions open (OCO orders remain active)");
            Console.WriteLine("  2. Close all positions at market");
            Console.WriteLine("  3. Close positions and cancel OCO orders");
            Console.Write("Your choice [1]: ");

            var choice = Console.ReadLine();

            switch (choice)
            {
                case "2":
                    await CloseAllPositionsAsync(cancelOco: false);
                    break;
                case "3":
                    await CloseAllPositionsAsync(cancelOco: true);
                    break;
                default:
                    Console.WriteLine("‚úÖ Positions kept open with OCO protection");
                    break;
            }
        }

        // 4. –£–≤–µ–¥–æ–º–∏—Ç—å
        if (_notifier != null)
        {
            await _notifier.SendMessage($"üõë Bot shutdown: {reason}");
        }

        Console.WriteLine("üëã Goodbye!");
    }

    private async Task CloseAllPositionsAsync(bool cancelOco)
    {
        Console.WriteLine("üì§ Closing all positions...");

        foreach (var position in _trader.GetOpenPositions())
        {
            if (cancelOco)
            {
                await _trader.CancelOcoOrdersForSymbol(position.Symbol);
            }

            await _trader.ClosePosition(position.Symbol, "Graceful shutdown");
            Console.WriteLine($"  ‚úÖ Closed {position.Symbol}");
        }

        Console.WriteLine("‚úÖ All positions closed");
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
var shutdown = new GracefulShutdown(stateManager, trader, telegramNotifier);

try
{
    await trader.StartAsync(shutdown.Token);
}
catch (OperationCanceledException)
{
    // –ù–æ—Ä–º–∞–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
}
```

---

### 2.4 Unit Tests

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç unit tests –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤.

**–†–µ—à–µ–Ω–∏–µ**: –î–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã —Å xUnit.

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–µ—Å—Ç–æ–≤**:
```
ComplexBot.Tests/
‚îú‚îÄ‚îÄ RiskManagerTests.cs
‚îú‚îÄ‚îÄ IndicatorsTests.cs
‚îú‚îÄ‚îÄ AdxTrendStrategyTests.cs
‚îú‚îÄ‚îÄ BacktestEngineTests.cs
‚îî‚îÄ‚îÄ TradeJournalTests.cs
```

**–ü—Ä–∏–º–µ—Ä—ã —Ç–µ—Å—Ç–æ–≤**:

```csharp
// RiskManagerTests.cs
public class RiskManagerTests
{
    [Fact]
    public void CalculatePositionSize_WithNormalDrawdown_ReturnsFullSize()
    {
        // Arrange
        var settings = new RiskSettings { RiskPerTradePercent = 1.5m };
        var manager = new RiskManager(settings, initialEquity: 10000m);

        // Act
        var size = manager.CalculatePositionSize(
            entryPrice: 45000m,
            stopLoss: 43500m  // 1500 USDT stop distance
        );

        // Assert
        // Risk = 10000 * 0.015 = 150 USDT
        // Size = 150 / 1500 = 0.1 BTC
        Assert.Equal(0.1m, size, precision: 4);
    }

    [Fact]
    public void CalculatePositionSize_WithDrawdown_ReducesSize()
    {
        // Arrange
        var settings = new RiskSettings { RiskPerTradePercent = 1.5m };
        var manager = new RiskManager(settings, initialEquity: 10000m);
        manager.UpdateEquity(8500m); // 15% drawdown

        // Act
        var size = manager.CalculatePositionSize(
            entryPrice: 45000m,
            stopLoss: 43500m
        );

        // Assert
        // At 15% drawdown, risk is reduced to 50%
        // Adjusted risk = 8500 * 0.015 * 0.5 = 63.75 USDT
        // Size = 63.75 / 1500 = 0.0425 BTC
        Assert.Equal(0.0425m, size, precision: 4);
    }

    [Fact]
    public void CanOpenPosition_WithExceededDrawdown_ReturnsFalse()
    {
        var settings = new RiskSettings { MaxDrawdownPercent = 20m };
        var manager = new RiskManager(settings, initialEquity: 10000m);
        manager.UpdateEquity(7900m); // 21% drawdown

        Assert.False(manager.CanOpenPosition());
    }

    [Fact]
    public void DailyDrawdown_ResetsAtMidnight()
    {
        var settings = new RiskSettings { MaxDailyDrawdownPercent = 3m };
        var manager = new RiskManager(settings, initialEquity: 10000m);

        // Simulate loss
        manager.UpdateEquity(9700m); // 3% daily loss
        Assert.True(manager.IsDailyLimitExceeded());

        // Simulate new day
        manager.SimulateNewDay(); // Internal method for testing
        Assert.False(manager.IsDailyLimitExceeded());
    }
}

// IndicatorsTests.cs
public class IndicatorsTests
{
    [Fact]
    public void CalculateEMA_WithKnownValues_ReturnsCorrectResult()
    {
        // Arrange
        var prices = new[] { 22.27m, 22.19m, 22.08m, 22.17m, 22.18m,
                            22.13m, 22.23m, 22.43m, 22.24m, 22.29m };

        // Act
        var ema = Indicators.CalculateEMA(prices.ToList(), period: 10);

        // Assert
        Assert.Equal(22.22m, ema, precision: 2);
    }

    [Fact]
    public void CalculateATR_WithGap_IncludesTrueRange()
    {
        // Arrange
        var candles = new List<Candle>
        {
            new(default, 100, 105, 98, 102, 1000, default),  // H-L = 7
            new(default, 103, 108, 101, 107, 1000, default), // Gap up, TR includes gap
        };

        // Act
        var atr = Indicators.CalculateATR(candles, period: 2);

        // Assert
        // True Range for second candle = max(108-101, |108-102|, |101-102|) = max(7, 6, 1) = 7
        Assert.True(atr > 0);
    }

    [Fact]
    public void CalculateADX_InTrend_ReturnsHighValue()
    {
        // Arrange - Create strong uptrend data
        var candles = GenerateUptrendCandles(50);

        // Act
        var (adx, plusDi, minusDi) = Indicators.CalculateADX(candles, period: 14);

        // Assert
        Assert.True(adx > 25); // Strong trend
        Assert.True(plusDi > minusDi); // Uptrend
    }

    private List<Candle> GenerateUptrendCandles(int count)
    {
        var candles = new List<Candle>();
        decimal price = 100;

        for (int i = 0; i < count; i++)
        {
            price *= 1.02m; // 2% daily increase
            candles.Add(new Candle(
                OpenTime: DateTime.UtcNow.AddDays(-count + i),
                Open: price * 0.99m,
                High: price * 1.01m,
                Low: price * 0.98m,
                Close: price,
                Volume: 1000,
                CloseTime: DateTime.UtcNow.AddDays(-count + i + 1)
            ));
        }

        return candles;
    }
}

// AdxTrendStrategyTests.cs
public class AdxTrendStrategyTests
{
    [Fact]
    public void CheckEntry_AllConditionsMet_ReturnsBuySignal()
    {
        // Arrange
        var settings = new StrategySettings();
        var strategy = new AdxTrendStrategy(settings);

        var candles = GenerateBullishSetup();
        strategy.UpdateIndicators(candles);

        // Act
        var signal = strategy.CheckEntryConditions(candles.Last());

        // Assert
        Assert.Equal(SignalType.Buy, signal.Type);
        Assert.NotNull(signal.StopLoss);
        Assert.NotNull(signal.TakeProfit);
    }

    [Fact]
    public void CheckEntry_LowADX_ReturnsNoSignal()
    {
        // Arrange - Ranging market with low ADX
        var settings = new StrategySettings { AdxThreshold = 25 };
        var strategy = new AdxTrendStrategy(settings);

        var candles = GenerateRangingMarket(); // ADX < 20
        strategy.UpdateIndicators(candles);

        // Act
        var signal = strategy.CheckEntryConditions(candles.Last());

        // Assert
        Assert.Equal(SignalType.None, signal.Type);
    }

    [Fact]
    public void CheckExit_StopLossHit_ReturnsExitSignal()
    {
        // Arrange
        var settings = new StrategySettings();
        var strategy = new AdxTrendStrategy(settings);

        strategy.OpenPosition(SignalType.Buy, entryPrice: 45000m, stopLoss: 43500m);

        var exitCandle = new Candle(default, 44000, 44100, 43400, 43600, 1000, default);

        // Act
        var signal = strategy.CheckExitConditions(exitCandle);

        // Assert
        Assert.Equal(SignalType.Exit, signal.Type);
        Assert.Contains("stop loss", signal.Reason.ToLower());
    }
}
```

---

### 2.5 Integration Tests –Ω–∞ Testnet

```csharp
[Collection("Binance Testnet")]
public class BinanceIntegrationTests : IAsyncLifetime
{
    private BinanceLiveTrader _trader;
    private IBinanceRestClient _client;

    public async Task InitializeAsync()
    {
        var settings = new LiveTraderSettings
        {
            Symbol = "BTCUSDT",
            UseTestnet = true,
            PaperTrade = false, // Real testnet orders
            ApiKey = Environment.GetEnvironmentVariable("BINANCE_TESTNET_KEY")!,
            ApiSecret = Environment.GetEnvironmentVariable("BINANCE_TESTNET_SECRET")!
        };

        _trader = new BinanceLiveTrader(settings);
        await _trader.InitializeAsync();
    }

    public async Task DisposeAsync()
    {
        await _trader.DisposeAsync();
    }

    [Fact]
    public async Task PlaceMarketOrder_OnTestnet_Succeeds()
    {
        // Act
        var result = await _trader.PlaceMarketOrder(
            symbol: "BTCUSDT",
            side: OrderSide.Buy,
            quantity: 0.001m
        );

        // Assert
        Assert.True(result.Success);
        Assert.True(result.FilledQuantity > 0);

        // Cleanup
        await _trader.PlaceMarketOrder("BTCUSDT", OrderSide.Sell, result.FilledQuantity);
    }

    [Fact]
    public async Task PlaceOcoOrder_OnTestnet_CreatesValidOrder()
    {
        // Arrange - First buy some BTC
        await _trader.PlaceMarketOrder("BTCUSDT", OrderSide.Buy, 0.001m);
        var currentPrice = await _trader.GetCurrentPrice("BTCUSDT");

        // Act
        var result = await _trader.PlaceOcoOrder(
            symbol: "BTCUSDT",
            side: OrderSide.Sell,
            quantity: 0.001m,
            stopLossPrice: currentPrice * 0.95m,
            stopLossLimitPrice: currentPrice * 0.949m,
            takeProfitPrice: currentPrice * 1.05m
        );

        // Assert
        Assert.True(result.Success);
        Assert.True(result.OrderListId > 0);

        // Cleanup
        await _trader.CancelOcoOrder("BTCUSDT", result.OrderListId);
        await _trader.PlaceMarketOrder("BTCUSDT", OrderSide.Sell, 0.001m);
    }
}
```

---

## –§–∞–∑–∞ 3: –£–ª—É—á—à–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

### 3.1 Volatility Regime Filter

**–ü—Ä–æ–±–ª–µ–º–∞**: –°—Ç—Ä–∞—Ç–µ–≥–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ –≤ —Ä–∞–∑–Ω—ã—Ö —Ä—ã–Ω–æ—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏—è—Ö.

**–†–µ—à–µ–Ω–∏–µ**: –û–ø—Ä–µ–¥–µ–ª—è—Ç—å —Ä–µ–∂–∏–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –∏ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.

```csharp
public enum VolatilityRegime
{
    Low,      // ATR < 20 percentile
    Normal,   // 20-80 percentile
    High,     // > 80 percentile
    Extreme   // > 95 percentile (don't trade)
}

public class VolatilityFilter
{
    private readonly int _lookbackPeriod;
    private readonly List<decimal> _atrHistory = new();

    public VolatilityFilter(int lookbackPeriod = 100)
    {
        _lookbackPeriod = lookbackPeriod;
    }

    public void UpdateATR(decimal currentAtr)
    {
        _atrHistory.Add(currentAtr);
        if (_atrHistory.Count > _lookbackPeriod)
        {
            _atrHistory.RemoveAt(0);
        }
    }

    public VolatilityRegime GetCurrentRegime()
    {
        if (_atrHistory.Count < _lookbackPeriod / 2)
        {
            return VolatilityRegime.Normal; // Not enough data
        }

        var sorted = _atrHistory.OrderBy(x => x).ToList();
        var currentAtr = _atrHistory.Last();
        var percentile = (decimal)sorted.IndexOf(sorted.First(x => x >= currentAtr)) / sorted.Count * 100;

        return percentile switch
        {
            >= 95 => VolatilityRegime.Extreme,
            >= 80 => VolatilityRegime.High,
            >= 20 => VolatilityRegime.Normal,
            _ => VolatilityRegime.Low
        };
    }

    public StrategySettings AdjustSettings(StrategySettings baseSettings, VolatilityRegime regime)
    {
        return regime switch
        {
            VolatilityRegime.Extreme => baseSettings with
            {
                // –ù–µ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å –≤ —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
            },
            VolatilityRegime.High => baseSettings with
            {
                AtrStopMultiplier = baseSettings.AtrStopMultiplier * 1.5m, // –®–∏—Ä–µ —Å—Ç–æ–ø—ã
                AdxThreshold = 30m, // –¢—Ä–µ–±–æ–≤–∞—Ç—å –±–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–π —Ç—Ä–µ–Ω–¥
                VolumeThreshold = 2.0m // –¢—Ä–µ–±–æ–≤–∞—Ç—å –±–æ–ª—å—à–∏–π –æ–±—ä—ë–º
            },
            VolatilityRegime.Low => baseSettings with
            {
                AtrStopMultiplier = baseSettings.AtrStopMultiplier * 0.75m, // –£–∂–µ —Å—Ç–æ–ø—ã
                AdxThreshold = 20m // –ú–æ–∂–Ω–æ –≤—Ö–æ–¥–∏—Ç—å –ø—Ä–∏ –º–µ–Ω—å—à–µ–º ADX
            },
            _ => baseSettings
        };
    }

    public bool ShouldTrade(VolatilityRegime regime)
    {
        return regime != VolatilityRegime.Extreme;
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:
public TradeSignal CheckEntryConditions(Candle candle)
{
    var regime = _volatilityFilter.GetCurrentRegime();

    if (!_volatilityFilter.ShouldTrade(regime))
    {
        return TradeSignal.None("Extreme volatility - no trading");
    }

    var adjustedSettings = _volatilityFilter.AdjustSettings(_settings, regime);

    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å adjustedSettings –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π
    // ...
}
```

---

### 3.2 RSI Divergence –¥–ª—è –≤—ã—Ö–æ–¥–∞

**–ü—Ä–æ–±–ª–µ–º–∞**: –ù–µ—Ç —Ä–∞–Ω–Ω–µ–≥–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ —Ä–∞–∑–≤–æ—Ä–æ—Ç–µ —Ç—Ä–µ–Ω–¥–∞.

**–†–µ—à–µ–Ω–∏–µ**: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–π RSI.

```csharp
public class DivergenceDetector
{
    public enum DivergenceType
    {
        None,
        BullishRegular,    // –¶–µ–Ω–∞: lower low, RSI: higher low
        BearishRegular,    // –¶–µ–Ω–∞: higher high, RSI: lower high
        BullishHidden,     // –¶–µ–Ω–∞: higher low, RSI: lower low
        BearishHidden      // –¶–µ–Ω–∞: lower high, RSI: higher high
    }

    private readonly int _lookbackBars;
    private readonly decimal _minPriceChange;

    public DivergenceDetector(int lookbackBars = 14, decimal minPriceChangePercent = 1m)
    {
        _lookbackBars = lookbackBars;
        _minPriceChange = minPriceChangePercent;
    }

    public DivergenceType Detect(List<Candle> candles, List<decimal> rsiValues)
    {
        if (candles.Count < _lookbackBars || rsiValues.Count < _lookbackBars)
            return DivergenceType.None;

        var recentCandles = candles.TakeLast(_lookbackBars).ToList();
        var recentRsi = rsiValues.TakeLast(_lookbackBars).ToList();

        // –ù–∞–π—Ç–∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã —Ü–µ–Ω—ã
        var priceHighs = FindLocalMaxima(recentCandles.Select(c => c.High).ToList());
        var priceLows = FindLocalMinima(recentCandles.Select(c => c.Low).ToList());

        // –ù–∞–π—Ç–∏ –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã RSI
        var rsiHighs = FindLocalMaxima(recentRsi);
        var rsiLows = FindLocalMinima(recentRsi);

        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å bearish divergence (–¥–ª—è –≤—ã—Ö–æ–¥–∞ –∏–∑ –ª–æ–Ω–≥–∞)
        if (priceHighs.Count >= 2 && rsiHighs.Count >= 2)
        {
            var lastPriceHigh = priceHighs.Last();
            var prevPriceHigh = priceHighs[^2];
            var lastRsiHigh = rsiHighs.Last();
            var prevRsiHigh = rsiHighs[^2];

            // Regular bearish: price higher high, RSI lower high
            if (lastPriceHigh.value > prevPriceHigh.value * (1 + _minPriceChange / 100) &&
                lastRsiHigh.value < prevRsiHigh.value)
            {
                return DivergenceType.BearishRegular;
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å bullish divergence (–¥–ª—è –≤—ã—Ö–æ–¥–∞ –∏–∑ —à–æ—Ä—Ç–∞)
        if (priceLows.Count >= 2 && rsiLows.Count >= 2)
        {
            var lastPriceLow = priceLows.Last();
            var prevPriceLow = priceLows[^2];
            var lastRsiLow = rsiLows.Last();
            var prevRsiLow = rsiLows[^2];

            // Regular bullish: price lower low, RSI higher low
            if (lastPriceLow.value < prevPriceLow.value * (1 - _minPriceChange / 100) &&
                lastRsiLow.value > prevRsiLow.value)
            {
                return DivergenceType.BullishRegular;
            }
        }

        return DivergenceType.None;
    }

    private List<(int index, decimal value)> FindLocalMaxima(List<decimal> values)
    {
        var maxima = new List<(int, decimal)>();
        for (int i = 1; i < values.Count - 1; i++)
        {
            if (values[i] > values[i - 1] && values[i] > values[i + 1])
            {
                maxima.Add((i, values[i]));
            }
        }
        return maxima;
    }

    private List<(int index, decimal value)> FindLocalMinima(List<decimal> values)
    {
        var minima = new List<(int, decimal)>();
        for (int i = 1; i < values.Count - 1; i++)
        {
            if (values[i] < values[i - 1] && values[i] < values[i + 1])
            {
                minima.Add((i, values[i]));
            }
        }
        return minima;
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –≤—ã—Ö–æ–¥–∞:
public TradeSignal CheckExitConditions(Candle candle)
{
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ...

    var divergence = _divergenceDetector.Detect(_candles, _rsiValues);

    if (_currentPosition == SignalType.Buy &&
        divergence == DivergenceType.BearishRegular)
    {
        return new TradeSignal(
            Symbol: _symbol,
            Type: SignalType.Exit,
            Price: candle.Close,
            Reason: "Bearish RSI divergence detected"
        );
    }

    if (_currentPosition == SignalType.Sell &&
        divergence == DivergenceType.BullishRegular)
    {
        return new TradeSignal(
            Symbol: _symbol,
            Type: SignalType.Exit,
            Price: candle.Close,
            Reason: "Bullish RSI divergence detected"
        );
    }

    // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ...
}
```

---

### 3.3 –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç—ã

**–ü—Ä–æ–±–ª–µ–º–∞**: –°–µ–π—á–∞—Å —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç, —É–ø—É—Å–∫–∞–µ—Ç—Å—è –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª –±–æ–ª—å—à–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è.

**–†–µ—à–µ–Ω–∏–µ**: –°—Ç—É–ø–µ–Ω—á–∞—Ç—ã–µ –≤—ã—Ö–æ–¥—ã —Å —Ç—Ä–µ–π–ª–∏–Ω–≥–æ–º.

```csharp
public class ScaledExitManager
{
    public record ExitLevel
    {
        public decimal RMultiple { get; init; }     // –í—ã—Ö–æ–¥ –Ω–∞ N*R –ø—Ä–∏–±—ã–ª–∏
        public decimal ExitPercent { get; init; }   // –ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –≤—ã—Ö–æ–¥–∞
        public bool MoveStopToBreakeven { get; init; }
        public decimal? NewTrailingMultiplier { get; init; } // –ù–æ–≤—ã–π ATR multiplier
        public bool Triggered { get; set; } = false;
    }

    private readonly List<ExitLevel> _exitLevels;
    private decimal _entryPrice;
    private decimal _initialStopLoss;
    private decimal _riskPerUnit;
    private decimal _remainingPosition = 1.0m;

    public ScaledExitManager()
    {
        // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: 25% –Ω–∞ 1R, 25% –Ω–∞ 2R, 50% trailing
        _exitLevels = new List<ExitLevel>
        {
            new ExitLevel
            {
                RMultiple = 1.0m,
                ExitPercent = 0.25m,
                MoveStopToBreakeven = true,
                NewTrailingMultiplier = null
            },
            new ExitLevel
            {
                RMultiple = 2.0m,
                ExitPercent = 0.25m,
                MoveStopToBreakeven = false,
                NewTrailingMultiplier = 1.5m  // Tighter trailing –ø–æ—Å–ª–µ 2R
            },
            new ExitLevel
            {
                RMultiple = 3.0m,
                ExitPercent = 0.25m,
                MoveStopToBreakeven = false,
                NewTrailingMultiplier = 1.0m  // –ï—â—ë —Çighter
            }
            // –û—Å—Ç–∞–≤—à–∏–µ—Å—è 25% –≤—ã—Ö–æ–¥—è—Ç –ø–æ —Ç—Ä–µ–π–ª–∏–Ω–≥ —Å—Ç–æ–ø—É
        };
    }

    public void Initialize(decimal entryPrice, decimal stopLoss, SignalType direction)
    {
        _entryPrice = entryPrice;
        _initialStopLoss = stopLoss;
        _riskPerUnit = direction == SignalType.Buy
            ? entryPrice - stopLoss
            : stopLoss - entryPrice;
        _remainingPosition = 1.0m;

        foreach (var level in _exitLevels)
        {
            level.Triggered = false;
        }
    }

    public List<TradeSignal> CheckExits(decimal currentPrice, SignalType direction,
        decimal currentAtr, string symbol)
    {
        var signals = new List<TradeSignal>();

        decimal currentPnlR = direction == SignalType.Buy
            ? (currentPrice - _entryPrice) / _riskPerUnit
            : (_entryPrice - currentPrice) / _riskPerUnit;

        foreach (var level in _exitLevels.Where(l => !l.Triggered))
        {
            if (currentPnlR >= level.RMultiple)
            {
                level.Triggered = true;

                var exitQuantityPercent = level.ExitPercent / _remainingPosition;
                _remainingPosition -= level.ExitPercent;

                signals.Add(new TradeSignal(
                    Symbol: symbol,
                    Type: SignalType.PartialExit,
                    Price: currentPrice,
                    Reason: $"Take profit at {level.RMultiple}R",
                    PartialExitPercent: exitQuantityPercent,
                    MoveStopToBreakeven: level.MoveStopToBreakeven
                ));

                if (level.NewTrailingMultiplier.HasValue)
                {
                    // –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–µ–π–ª–∏–Ω–≥ —Å—Ç–æ–ø–∞
                    var newStop = direction == SignalType.Buy
                        ? currentPrice - currentAtr * level.NewTrailingMultiplier.Value
                        : currentPrice + currentAtr * level.NewTrailingMultiplier.Value;

                    signals.Add(new TradeSignal(
                        Symbol: symbol,
                        Type: SignalType.UpdateStop,
                        Price: currentPrice,
                        StopLoss: newStop,
                        Reason: $"Tighten trailing stop to {level.NewTrailingMultiplier.Value}x ATR"
                    ));
                }
            }
        }

        return signals;
    }

    public decimal GetRemainingPositionPercent() => _remainingPosition;
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
public class AdxTrendStrategy
{
    private readonly ScaledExitManager _exitManager = new();

    public TradeSignal CheckExitConditions(Candle candle)
    {
        var exitSignals = _exitManager.CheckExits(
            currentPrice: candle.Close,
            direction: _currentPosition,
            currentAtr: _currentAtr,
            symbol: _symbol
        );

        foreach (var signal in exitSignals)
        {
            // –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –∫–∞–∂–¥—ã–π —Å–∏–≥–Ω–∞–ª
            if (signal.Type == SignalType.PartialExit)
            {
                yield return signal;
            }
        }

        // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—ã—Ö–æ–¥–∞ ...
    }
}
```

---

### 3.4 –ú—É–ª—å—Ç–∏-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è

**–ü—Ä–æ–±–ª–µ–º–∞**: –ë–æ—Ç —Ç–æ—Ä–≥—É–µ—Ç —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–π –ø–∞—Ä–æ–π.

**–†–µ—à–µ–Ω–∏–µ**: Multi-symbol –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞.

```csharp
public class MultiSymbolTrader
{
    private readonly Dictionary<string, SymbolTrader> _traders = new();
    private readonly PortfolioRiskManager _portfolioManager;
    private readonly TelegramNotifier _notifier;

    public record SymbolConfig
    {
        public string Symbol { get; init; } = "";
        public KlineInterval Interval { get; init; }
        public decimal AllocationPercent { get; init; } // % –æ—Ç –ø–æ—Ä—Ç—Ñ–µ–ª—è
        public StrategySettings? CustomSettings { get; init; }
    }

    public MultiSymbolTrader(
        List<SymbolConfig> symbols,
        decimal totalCapital,
        PortfolioRiskManager portfolioManager,
        TelegramNotifier notifier)
    {
        _portfolioManager = portfolioManager;
        _notifier = notifier;

        foreach (var config in symbols)
        {
            var symbolCapital = totalCapital * config.AllocationPercent / 100;
            var settings = config.CustomSettings ?? new StrategySettings();

            _traders[config.Symbol] = new SymbolTrader(
                symbol: config.Symbol,
                interval: config.Interval,
                capital: symbolCapital,
                settings: settings,
                portfolioManager: _portfolioManager
            );
        }
    }

    public async Task StartAllAsync(CancellationToken ct)
    {
        var tasks = _traders.Values.Select(t => t.StartAsync(ct));

        // –ó–∞–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ —Ç—Ä–µ–π–¥–µ—Ä—ã –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        await Task.WhenAll(tasks);
    }

    public PortfolioStatus GetPortfolioStatus()
    {
        var positions = _traders.Values
            .Where(t => t.HasOpenPosition)
            .Select(t => new PositionInfo
            {
                Symbol = t.Symbol,
                Direction = t.CurrentDirection,
                EntryPrice = t.EntryPrice,
                CurrentPrice = t.CurrentPrice,
                UnrealizedPnL = t.UnrealizedPnL,
                RiskAmount = t.RiskAmount
            })
            .ToList();

        return new PortfolioStatus
        {
            TotalEquity = _traders.Values.Sum(t => t.CurrentEquity),
            UnrealizedPnL = positions.Sum(p => p.UnrealizedPnL),
            OpenPositions = positions,
            TotalRisk = positions.Sum(p => p.RiskAmount),
            DrawdownPercent = _portfolioManager.GetTotalDrawdownPercent()
        };
    }
}

public class SymbolTrader
{
    private readonly string _symbol;
    private readonly AdxTrendStrategy _strategy;
    private readonly RiskManager _riskManager;
    private readonly PortfolioRiskManager _portfolioManager;

    public async Task StartAsync(CancellationToken ct)
    {
        // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–≤–µ—á–∏
        await SubscribeToKlines(ct);

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–≤–µ—á–µ–π
        while (!ct.IsCancellationRequested)
        {
            await ProcessNextCandle();
        }
    }

    private async Task ProcessNextCandle()
    {
        // –ü–æ–ª—É—á–∏—Ç—å —Å–∏–≥–Ω–∞–ª –æ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        var signal = _strategy.ProcessCandle(_lastCandle);

        if (signal.Type == SignalType.Buy || signal.Type == SignalType.Sell)
        {
            // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—å–Ω—ã–π —Ä–∏—Å–∫
            if (_portfolioManager.CanOpenPosition(_symbol))
            {
                await ExecuteEntry(signal);
            }
        }
        else if (signal.Type == SignalType.Exit || signal.Type == SignalType.PartialExit)
        {
            await ExecuteExit(signal);
        }
    }
}

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:
var symbols = new List<SymbolConfig>
{
    new() { Symbol = "BTCUSDT", Interval = KlineInterval.FourHour, AllocationPercent = 40 },
    new() { Symbol = "ETHUSDT", Interval = KlineInterval.FourHour, AllocationPercent = 30 },
    new() { Symbol = "SOLUSDT", Interval = KlineInterval.FourHour, AllocationPercent = 15 },
    new() { Symbol = "BNBUSDT", Interval = KlineInterval.FourHour, AllocationPercent = 15 },
};

var multiTrader = new MultiSymbolTrader(
    symbols: symbols,
    totalCapital: 10000m,
    portfolioManager: new PortfolioRiskManager(maxTotalDrawdown: 25m),
    notifier: telegramNotifier
);

await multiTrader.StartAllAsync(cancellationToken);
```

---

## –§–∞–∑–∞ 4: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ñ–∏—á–∏

### 4.1 Strategy Ensemble

**–ò–¥–µ—è**: –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Å–∏–≥–Ω–∞–ª—ã –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π.

```csharp
public class StrategyEnsemble
{
    public record StrategyVote
    {
        public string StrategyName { get; init; } = "";
        public SignalType Signal { get; init; }
        public decimal Confidence { get; init; }  // 0-1
        public decimal Weight { get; init; }      // –í–µ—Å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
    }

    private readonly List<(IStrategy strategy, decimal weight)> _strategies;
    private readonly decimal _minimumAgreement;  // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π % —Å–æ–≥–ª–∞—Å–∏—è

    public StrategyEnsemble(decimal minimumAgreement = 0.6m)
    {
        _minimumAgreement = minimumAgreement;
        _strategies = new List<(IStrategy, decimal)>
        {
            (new AdxTrendStrategy(new StrategySettings()), 0.4m),
            (new MaStrategy(new MaSettings()), 0.3m),
            (new RsiStrategy(new RsiSettings()), 0.3m)
        };
    }

    public (SignalType signal, decimal confidence) GetConsensusSignal(List<Candle> candles)
    {
        var votes = new List<StrategyVote>();

        foreach (var (strategy, weight) in _strategies)
        {
            var signal = strategy.GenerateSignal(candles);
            votes.Add(new StrategyVote
            {
                StrategyName = strategy.Name,
                Signal = signal.Type,
                Confidence = signal.Confidence,
                Weight = weight
            });
        }

        // –ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –≤–∑–≤–µ—à–µ–Ω–Ω–æ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ
        var buyScore = votes
            .Where(v => v.Signal == SignalType.Buy)
            .Sum(v => v.Weight * v.Confidence);

        var sellScore = votes
            .Where(v => v.Signal == SignalType.Sell)
            .Sum(v => v.Weight * v.Confidence);

        var totalWeight = _strategies.Sum(s => s.weight);

        if (buyScore / totalWeight >= _minimumAgreement)
        {
            return (SignalType.Buy, buyScore / totalWeight);
        }

        if (sellScore / totalWeight >= _minimumAgreement)
        {
            return (SignalType.Sell, sellScore / totalWeight);
        }

        return (SignalType.None, 0);
    }
}
```

---

### 4.2 Machine Learning Parameter Optimization

**–ò–¥–µ—è**: –ì–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –ø–æ–¥–±–æ—Ä–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.

```csharp
public class GeneticOptimizer
{
    public record Chromosome
    {
        public StrategySettings Settings { get; init; } = new();
        public decimal Fitness { get; set; }
    }

    private readonly int _populationSize;
    private readonly int _generations;
    private readonly decimal _mutationRate;
    private readonly List<Candle> _trainingData;

    public GeneticOptimizer(
        List<Candle> trainingData,
        int populationSize = 100,
        int generations = 50,
        decimal mutationRate = 0.1m)
    {
        _trainingData = trainingData;
        _populationSize = populationSize;
        _generations = generations;
        _mutationRate = mutationRate;
    }

    public StrategySettings Optimize()
    {
        // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ø—É–ª—è—Ü–∏—é
        var population = InitializePopulation();

        for (int gen = 0; gen < _generations; gen++)
        {
            // 2. –û—Ü–µ–Ω–∏—Ç—å fitness –∫–∞–∂–¥–æ–π –æ—Å–æ–±–∏
            foreach (var chromosome in population)
            {
                chromosome.Fitness = EvaluateFitness(chromosome.Settings);
            }

            // 3. –°–µ–ª–µ–∫—Ü–∏—è –ª—É—á—à–∏—Ö
            var parents = SelectBest(population, count: _populationSize / 2);

            // 4. –ö—Ä–æ—Å—Å–æ–≤–µ—Ä
            var offspring = Crossover(parents);

            // 5. –ú—É—Ç–∞—Ü–∏—è
            Mutate(offspring);

            // 6. –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –ø–æ–ø—É–ª—è—Ü–∏–∏
            population = parents.Concat(offspring).ToList();

            // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
            var best = population.MaxBy(c => c.Fitness);
            Console.WriteLine($"Gen {gen}: Best fitness = {best?.Fitness:F4}");
        }

        return population.MaxBy(c => c.Fitness)!.Settings;
    }

    private List<Chromosome> InitializePopulation()
    {
        var random = new Random();
        return Enumerable.Range(0, _populationSize)
            .Select(_ => new Chromosome
            {
                Settings = new StrategySettings
                {
                    AdxPeriod = random.Next(10, 20),
                    AdxThreshold = random.Next(20, 35),
                    FastEmaPeriod = random.Next(10, 30),
                    SlowEmaPeriod = random.Next(40, 100),
                    AtrStopMultiplier = 1.5m + (decimal)random.NextDouble() * 2,
                    VolumeThreshold = 1.0m + (decimal)random.NextDouble() * 1.5m
                }
            })
            .ToList();
    }

    private decimal EvaluateFitness(StrategySettings settings)
    {
        var engine = new BacktestEngine(_trainingData, settings);
        var results = engine.Run();

        // Fitness = Sharpe ratio —Å penalty –∑–∞ drawdown
        var sharpe = results.SharpeRatio;
        var drawdownPenalty = Math.Max(0, results.MaxDrawdownPercent - 20) * 0.1m;

        return sharpe - drawdownPenalty;
    }

    private Chromosome Crossover(Chromosome parent1, Chromosome parent2)
    {
        var random = new Random();

        return new Chromosome
        {
            Settings = new StrategySettings
            {
                AdxPeriod = random.NextDouble() > 0.5
                    ? parent1.Settings.AdxPeriod
                    : parent2.Settings.AdxPeriod,
                AdxThreshold = random.NextDouble() > 0.5
                    ? parent1.Settings.AdxThreshold
                    : parent2.Settings.AdxThreshold,
                // ... –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
            }
        };
    }

    private void Mutate(List<Chromosome> population)
    {
        var random = new Random();

        foreach (var chromosome in population)
        {
            if ((decimal)random.NextDouble() < _mutationRate)
            {
                // –°–ª—É—á–∞–π–Ω–∞—è –º—É—Ç–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
                var paramIndex = random.Next(6);
                chromosome.Settings = paramIndex switch
                {
                    0 => chromosome.Settings with { AdxPeriod = random.Next(10, 20) },
                    1 => chromosome.Settings with { AdxThreshold = random.Next(20, 35) },
                    2 => chromosome.Settings with { FastEmaPeriod = random.Next(10, 30) },
                    3 => chromosome.Settings with { SlowEmaPeriod = random.Next(40, 100) },
                    4 => chromosome.Settings with { AtrStopMultiplier = 1.5m + (decimal)random.NextDouble() * 2 },
                    _ => chromosome.Settings with { VolumeThreshold = 1.0m + (decimal)random.NextDouble() * 1.5m }
                };
            }
        }
    }
}
```

---

### 4.3 News/Events Filter

**–ò–¥–µ—è**: –ù–µ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å –≤–æ –≤—Ä–µ–º—è –≤–∞–∂–Ω—ã—Ö –Ω–æ–≤–æ—Å—Ç–µ–π.

```csharp
public class EconomicCalendarFilter
{
    private readonly HttpClient _httpClient;
    private readonly List<EconomicEvent> _events = new();

    public record EconomicEvent
    {
        public DateTime Time { get; init; }
        public string Title { get; init; } = "";
        public string Currency { get; init; } = "";
        public ImpactLevel Impact { get; init; }
    }

    public enum ImpactLevel { Low, Medium, High }

    public async Task LoadEventsAsync()
    {
        // –ü—Ä–∏–º–µ—Ä: –∑–∞–≥—Ä—É–∑–∫–∞ –∏–∑ investing.com API –∏–ª–∏ –¥—Ä—É–≥–æ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–µ–Ω API key –∏–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥

        // –î–ª—è –∫—Ä–∏–ø—Ç–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π:
        // - FOMC –∑–∞—Å–µ–¥–∞–Ω–∏—è
        // - CPI –¥–∞–Ω–Ω—ã–µ
        // - –ö—Ä–∏–ø—Ç–æ-–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
        // - Halving events
        // - Major upgrades (Ethereum merge, etc.)
    }

    public bool ShouldTrade(DateTime time)
    {
        // –ù–µ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å –∑–∞ 30 –º–∏–Ω—É—Ç –¥–æ –∏ –ø–æ—Å–ª–µ –≤—ã—Å–æ–∫–æ-–∏–º–ø–∞–∫—Ç–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π
        var buffer = TimeSpan.FromMinutes(30);

        var nearbyHighImpact = _events
            .Where(e => e.Impact == ImpactLevel.High)
            .Any(e => Math.Abs((e.Time - time).TotalMinutes) < buffer.TotalMinutes);

        if (nearbyHighImpact)
        {
            Console.WriteLine("‚ö†Ô∏è High impact event nearby, skipping trade");
            return false;
        }

        return true;
    }

    public List<EconomicEvent> GetUpcomingEvents(int hours = 24)
    {
        var now = DateTime.UtcNow;
        return _events
            .Where(e => e.Time > now && e.Time < now.AddHours(hours))
            .OrderBy(e => e.Time)
            .ToList();
    }
}
```

---

## –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π –ø–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ROADMAP IMPLEMENTATION                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                  ‚îÇ
‚îÇ  –§–ê–ó–ê 1: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ (–¥–æ live —Ç–æ—Ä–≥–æ–≤–ª–∏)                         ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                       ‚îÇ
‚îÇ  ‚ñ° 1.1 –î–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –ø–æ—Ç–µ—Ä—å                                     ‚îÇ
‚îÇ  ‚ñ° 1.2 –ñ—É—Ä–Ω–∞–ª —Å–¥–µ–ª–æ–∫ CSV                                        ‚îÇ
‚îÇ  ‚ñ° 1.3 –ë–∏—Ä–∂–µ–≤—ã–µ —Å—Ç–æ–ø-–æ—Ä–¥–µ—Ä–∞ (OCO)                               ‚îÇ
‚îÇ  ‚ñ° 1.4 Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è                                     ‚îÇ
‚îÇ  ‚ñ° 1.5 –†–µ–∞–ª—Ç–∞–π–º equity tracking                                 ‚îÇ
‚îÇ  ‚ñ° 1.6 –í–∞–ª–∏–¥–∞—Ü–∏—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–æ–≤                             ‚îÇ
‚îÇ  ‚ñ° 1.7 –õ–∏–º–∏—Ç–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞                                          ‚îÇ
‚îÇ  ‚ñ° 1.8 –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å                                       ‚îÇ
‚îÇ  ‚ñ° 1.9 –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –ø–æ–∑–∏—Ü–∏–π                                       ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  –§–ê–ó–ê 2: –û–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å                                ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                ‚îÇ
‚îÇ  ‚ñ° 2.1 State persistence                                        ‚îÇ
‚îÇ  ‚ñ° 2.2 Reconnection logic                                       ‚îÇ
‚îÇ  ‚ñ° 2.3 Graceful shutdown                                        ‚îÇ
‚îÇ  ‚ñ° 2.4 Unit tests                                               ‚îÇ
‚îÇ  ‚ñ° 2.5 Integration tests                                        ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  –§–ê–ó–ê 3: –£–ª—É—á—à–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏                                    ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                     ‚îÇ
‚îÇ  ‚ñ° 3.1 Volatility regime filter                                 ‚îÇ
‚îÇ  ‚ñ° 3.2 RSI divergence –≤—ã—Ö–æ–¥—ã                                    ‚îÇ
‚îÇ  ‚ñ° 3.3 –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç—ã                               ‚îÇ
‚îÇ  ‚ñ° 3.4 –ú—É–ª—å—Ç–∏-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è                            ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  –§–ê–ó–ê 4: –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Ñ–∏—á–∏                                       ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                        ‚îÇ
‚îÇ  ‚ñ° 4.1 Strategy ensemble                                        ‚îÇ
‚îÇ  ‚ñ° 4.2 ML parameter optimization                                ‚îÇ
‚îÇ  ‚ñ° 4.3 News/events filter                                       ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞

| –ú–µ—Ç—Ä–∏–∫–∞ | –¢–µ–∫—É—â–µ–µ | –¶–µ–ª—å |
|---------|---------|------|
| Sharpe Ratio | N/A | > 1.5 |
| Max Drawdown | 20% limit | < 15% |
| Win Rate | N/A | > 45% |
| Profit Factor | N/A | > 1.5 |
| Average R-Multiple | N/A | > 0.5 |
| Daily Loss Limit | ‚ùå | 3% |
| Test Coverage | 0% | > 80% |

---

*–î–æ–∫—É–º–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω: 2026-01-01*
*–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: 2026-01-01*

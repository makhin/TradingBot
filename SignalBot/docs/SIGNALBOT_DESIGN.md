# SignalBot - Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚

## ĞĞ±Ğ·Ğ¾Ñ€

SignalBot - Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¸Ğ· Telegram ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ½Ğ° Binance Futures.

## Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

### ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹

```
1. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Telegram ĞºĞ°Ğ½Ğ°Ğ»Ñƒ Ñ‡ĞµÑ€ĞµĞ· WTelegramClient
2. ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ¼
3. ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ğ² ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚
4. Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ² (SL, leverage)
5. ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ½Ğ° Binance Futures
6. Ğ Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ Stop Loss Ğ¸ Take Profit Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
7. ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
8. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ…
9. Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
```

### Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ²Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²

```
#SYMBOL/USDT - LongğŸŸ¢ | ShortğŸ”´

Entry: X.XXXX
Stop Loss: X.XXXX

Target 1: X.XXXX
Target 2: X.XXXX
Target 3: X.XXXX
Target 4: X.XXXX

Leverage: xNN
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:**

```
#ICNT/USDT - LongğŸŸ¢

Entry: 0.3709
Stop Loss: 0.18569

Target 1: 0.37225
Target 2: 0.37243
Target 3: 0.37362
Target 4: 0.37452

Leverage: x32
```

```
#AVNT/USDT - LongğŸŸ¢

Entry: 0.3204
Stop Loss: 0.16064

Target 1: 0.32054
Target 2: 0.32303
Target 3: 0.3233
Target 4: 0.32379

Leverage: x32
```

---

## ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°

```
SignalBot/
â”œâ”€â”€ SignalBot.csproj
â”‚
â”œâ”€â”€ Program.cs                             # Entry point
â”œâ”€â”€ SignalBotRunner.cs                     # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ runner
â”‚
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Telegram/
â”‚   â”‚   â”œâ”€â”€ ITelegramSignalListener.cs     # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ TelegramSignalListener.cs      # WTelegramClient Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
â”‚   â”‚   â”œâ”€â”€ SignalParser.cs                # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ‚ĞµĞºÑÑ‚Ğ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
â”‚   â”‚   â””â”€â”€ SignalParserResult.cs          # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°
â”‚   â”‚
â”‚   â”œâ”€â”€ Validation/
â”‚   â”‚   â”œâ”€â”€ ISignalValidator.cs            # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ SignalValidator.cs             # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°
â”‚   â”‚   â””â”€â”€ ValidationResult.cs            # Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
â”‚   â”‚
â”‚   â”œâ”€â”€ Trading/
â”‚   â”‚   â”œâ”€â”€ ISignalTrader.cs               # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ SignalTrader.cs                # Ğ˜ÑĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
â”‚   â”‚   â”œâ”€â”€ IPositionManager.cs            # Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
â”‚   â”‚   â”œâ”€â”€ PositionManager.cs             # Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸ÑĞ¼Ğ¸
â”‚   â”‚   â””â”€â”€ TargetTracker.cs               # ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ targets
â”‚   â”‚
â”‚   â””â”€â”€ Monitoring/
â”‚       â”œâ”€â”€ OrderMonitor.cs                # ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¾Ñ€Ğ´ĞµÑ€Ğ¾Ğ²
â”‚       â””â”€â”€ PositionMonitor.cs             # ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
â”‚
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ TradingSignal.cs                   # Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ¸Ğ· Telegram
â”‚   â”œâ”€â”€ SignalPosition.cs                  # ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñƒ
â”‚   â”œâ”€â”€ TargetLevel.cs                     # Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ take profit
â”‚   â”œâ”€â”€ SignalDirection.cs                 # Long/Short enum
â”‚   â”œâ”€â”€ PositionStatus.cs                  # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ enum
â”‚   â””â”€â”€ SignalSource.cs                    # Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
â”‚
â”œâ”€â”€ Configuration/
â”‚   â”œâ”€â”€ SignalBotSettings.cs               # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
â”‚   â”œâ”€â”€ TelegramSettings.cs                # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Telegram
â”‚   â”œâ”€â”€ TradingSettings.cs                 # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ğ¸
â”‚   â””â”€â”€ RiskOverrideSettings.cs            # ĞŸĞµÑ€ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ñ€Ğ¸ÑĞºĞ°
â”‚
â”œâ”€â”€ State/
â”‚   â”œâ”€â”€ SignalBotState.cs                  # Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ°
â”‚   â””â”€â”€ SignalPositionStore.cs             # Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
â”‚
â””â”€â”€ appsettings.json
```

### Ğ”Ğ¸Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          SignalBot                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    Telegram     â”‚    â”‚    Signal    â”‚    â”‚     Signal      â”‚   â”‚
â”‚  â”‚    Listener     â”‚â”€â”€â”€â–¶â”‚    Parser    â”‚â”€â”€â”€â–¶â”‚    Validator    â”‚   â”‚
â”‚  â”‚                 â”‚    â”‚              â”‚    â”‚                 â”‚   â”‚
â”‚  â”‚ (WTelegramClient)â”‚    â”‚  (Regex)     â”‚    â”‚ (Risk checks)   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                       â”‚            â”‚
â”‚                                                       â–¼            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   Position      â”‚â—€â”€â”€â”€â”‚   Signal     â”‚â—€â”€â”€â”€â”‚   Trading       â”‚   â”‚
â”‚  â”‚   Manager       â”‚    â”‚   Trader     â”‚    â”‚   Signal        â”‚   â”‚
â”‚  â”‚                 â”‚    â”‚              â”‚    â”‚   (validated)   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚           â”‚                    â”‚                                   â”‚
â”‚           â–¼                    â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚   Position      â”‚    â”‚   Order      â”‚                          â”‚
â”‚  â”‚   Store         â”‚    â”‚   Monitor    â”‚                          â”‚
â”‚  â”‚                 â”‚    â”‚              â”‚                          â”‚
â”‚  â”‚ (JSON/SQLite)   â”‚    â”‚ (WebSocket)  â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚                    â”‚
                â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TradingBot.Core     â”‚  â”‚  TradingBot.Binance   â”‚
â”‚                       â”‚  â”‚                       â”‚
â”‚ â€¢ IRiskManager        â”‚  â”‚ â€¢ IBinanceFuturesClientâ”‚
â”‚ â€¢ IStateManager       â”‚  â”‚ â€¢ IOrderUpdateListener â”‚
â”‚ â€¢ INotifier           â”‚  â”‚ â€¢ IKlineListener      â”‚
â”‚ â€¢ Models              â”‚  â”‚                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ĞœĞ¾Ğ´ĞµĞ»Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

### TradingSignal

```csharp
/// <summary>
/// Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ», Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¸Ğ· Telegram ĞºĞ°Ğ½Ğ°Ğ»Ğ°
/// </summary>
public record TradingSignal
{
    // ĞœĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    public Guid Id { get; init; } = Guid.NewGuid();
    public string RawText { get; init; } = string.Empty;
    public DateTime ReceivedAt { get; init; } = DateTime.UtcNow;
    public SignalSource Source { get; init; }

    // Ğ Ğ°ÑĞ¿Ğ°Ñ€ÑĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    public string Symbol { get; init; } = string.Empty;        // "ICNTUSDT"
    public SignalDirection Direction { get; init; }             // Long/Short
    public decimal Entry { get; init; }                         // Ğ¦ĞµĞ½Ğ° Ğ²Ñ…Ğ¾Ğ´Ğ°
    public decimal OriginalStopLoss { get; init; }              // SL Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    public IReadOnlyList<decimal> Targets { get; init; } = [];  // T1, T2, T3, T4
    public int OriginalLeverage { get; init; }                  // Leverage Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°

    // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ/ÑĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
    public decimal AdjustedStopLoss { get; init; }              // Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ SL
    public int AdjustedLeverage { get; init; }                  // Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ leverage
    public decimal LiquidationPrice { get; init; }              // Ğ¦ĞµĞ½Ğ° Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
    public decimal RiskRewardRatio { get; init; }               // R:R Ğ´Ğ¾ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾ target

    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
    public bool IsValid { get; init; }
    public IReadOnlyList<string> ValidationWarnings { get; init; } = [];
}

public enum SignalDirection
{
    Long,
    Short
}

public record SignalSource
{
    public string ChannelName { get; init; } = string.Empty;
    public long ChannelId { get; init; }
    public int MessageId { get; init; }
}
```

### SignalPosition

```csharp
/// <summary>
/// ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñƒ
/// </summary>
public record SignalPosition
{
    // Ğ˜Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ
    public Guid Id { get; init; } = Guid.NewGuid();
    public Guid SignalId { get; init; }

    // ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    public string Symbol { get; init; } = string.Empty;
    public SignalDirection Direction { get; init; }
    public PositionStatus Status { get; init; }

    // Ğ¦ĞµĞ½Ñ‹
    public decimal PlannedEntryPrice { get; init; }
    public decimal ActualEntryPrice { get; init; }
    public decimal CurrentStopLoss { get; init; }
    public int Leverage { get; init; }

    // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾
    public decimal InitialQuantity { get; init; }
    public decimal RemainingQuantity { get; init; }
    public decimal FilledQuantity => InitialQuantity - RemainingQuantity;

    // Targets
    public IReadOnlyList<TargetLevel> Targets { get; init; } = [];
    public int TargetsHit => Targets.Count(t => t.IsHit);

    // ĞÑ€Ğ´ĞµÑ€Ğ° Ğ½Ğ° Ğ±Ğ¸Ñ€Ğ¶Ğµ
    public long? EntryOrderId { get; init; }
    public long? StopLossOrderId { get; init; }
    public IReadOnlyList<long> TakeProfitOrderIds { get; init; } = [];

    // Ğ’Ñ€ĞµĞ¼Ñ
    public DateTime CreatedAt { get; init; } = DateTime.UtcNow;
    public DateTime? OpenedAt { get; init; }
    public DateTime? ClosedAt { get; init; }

    // P&L
    public decimal RealizedPnl { get; init; }
    public decimal UnrealizedPnl { get; init; }
    public decimal Commission { get; init; }

    // ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ
    public PositionCloseReason? CloseReason { get; init; }
}

public enum PositionStatus
{
    Pending,         // Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½, Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
    Opening,         // ĞÑ€Ğ´ĞµÑ€ Ğ½Ğ° Ğ²Ñ…Ğ¾Ğ´ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½
    Open,            // ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°
    PartialClosed,   // Ğ§Ğ°ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ° Ğ¿Ğ¾ targets
    Closing,         // Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ² Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞµ
    Closed,          // ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°
    Cancelled,       // ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ° Ğ´Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ
    Failed           // ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ğ¸
}

public enum PositionCloseReason
{
    AllTargetsHit,
    StopLossHit,
    ManualClose,
    Liquidation,
    Error
}
```

### TargetLevel

```csharp
/// <summary>
/// Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ take profit
/// </summary>
public record TargetLevel
{
    public int Index { get; init; }                    // 0, 1, 2, 3
    public decimal Price { get; init; }                // Ğ¦ĞµĞ½Ğ° target
    public decimal PercentToClose { get; init; }       // % Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ (25%)
    public decimal QuantityToClose { get; init; }      // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ

    public bool IsHit { get; init; }
    public DateTime? HitAt { get; init; }
    public decimal? ActualClosePrice { get; init; }
    public long? OrderId { get; init; }

    // Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ
    public decimal? MoveStopLossTo { get; init; }      // ĞšÑƒĞ´Ğ° Ğ´Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒ SL Ğ¿Ğ¾ÑĞ»Ğµ hit
}
```

### SignalBotState

```csharp
/// <summary>
/// Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ğ° Ğ´Ğ»Ñ persistence
/// </summary>
public record SignalBotState
{
    public DateTime LastUpdate { get; init; } = DateTime.UtcNow;
    public string Version { get; init; } = "1.0";

    // ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    public IReadOnlyList<SignalPosition> OpenPositions { get; init; } = [];

    // ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ (Ğ½Ğµ ÑƒÑĞ¿ĞµĞ»Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ)
    public IReadOnlyList<TradingSignal> PendingSignals { get; init; } = [];

    // Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞµÑÑĞ¸Ğ¸
    public decimal SessionStartEquity { get; init; }
    public decimal CurrentEquity { get; init; }
    public int TotalSignalsReceived { get; init; }
    public int TotalPositionsOpened { get; init; }
    public int TotalPositionsClosed { get; init; }

    // ID Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ (Ğ´Ğ»Ñ Ğ´ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸)
    public Dictionary<long, int> LastProcessedMessageIds { get; init; } = new();
}
```

---

## ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

### appsettings.json

```json
{
  "SignalBot": {
    "Telegram": {
      "ApiId": 12345678,
      "ApiHash": "your_api_hash",
      "PhoneNumber": "+1234567890",
      "ChannelIds": [
        -1001234567890
      ],
      "SessionPath": "telegram_session.dat"
    },

    "Trading": {
      "DefaultSymbolSuffix": "USDT",
      "MarginType": "Isolated",
      "PositionMode": "OneWay",

      "EntryMode": "Market",
      "MaxConcurrentPositions": 5,
      "MinTimeBetweenSignals": "00:01:00",

      "TargetStrategy": "PartialClose",
      "TargetClosePercents": [25, 25, 25, 25],
      "MoveStopToBreakeven": true,
      "TrailingStopEnabled": false
    },

    "DuplicateHandling": {
      "SameDirection": "Ignore",
      "OppositeDirection": "Ignore",
      "MaxPositionsPerSymbol": 1,
      "MinTimeBetweenDuplicates": "00:05:00",
      "AllowDuplicateOnPartialClose": true
    },

    "PositionSizing": {
      "DefaultMode": "FixedAmount",
      "DefaultRiskPercent": 1.0,
      "DefaultFixedAmount": 100.0,
      "DefaultFixedMargin": 50.0,

      "SymbolOverrides": {
        "BTCUSDT": { "FixedAmount": 200.0 },
        "ETHUSDT": { "FixedAmount": 150.0 }
      },

      "Limits": {
        "MinPositionUsdt": 10.0,
        "MaxPositionUsdt": 1000.0,
        "MaxPositionPercent": 25.0,
        "MaxTotalExposurePercent": 80.0
      }
    },

    "Entry": {
      "MaxPriceDeviationPercent": 0.5,
      "DeviationAction": "Skip",
      "UseLimitOrder": false,
      "LimitOrderTtl": "00:05:00",
      "MaxSlippagePercent": 0.3
    },

    "Cooldown": {
      "Enabled": true,
      "CooldownAfterStopLoss": "00:15:00",
      "CooldownAfterLiquidation": "01:00:00",
      "ConsecutiveLossesForLongCooldown": 3,
      "LongCooldownDuration": "02:00:00",
      "ReduceSizeAfterLosses": true,
      "SizeMultiplierAfter1Loss": 0.75,
      "SizeMultiplierAfter2Losses": 0.5,
      "SizeMultiplierAfter3PlusLosses": 0.25
    },

    "Emergency": {
      "MaxDailyLossPercent": 5.0,
      "MaxSessionLossPercent": 10.0,
      "MaxLossAction": "StopNewTrades",
      "CloseAllOnEmergencyStop": true
    },

    "RiskOverride": {
      "Enabled": true,
      "MaxLeverage": 10,
      "UseSignalLeverage": false,

      "StopLossMode": "Calculate",
      "StopLossPercent": 2.0,
      "SafeDistanceFromLiquidation": 0.3,

      "RiskPerTradePercent": 1.0,
      "MaxDrawdownPercent": 20.0,
      "MaxDailyLossPercent": 5.0
    },

    "Notifications": {
      "TelegramBotToken": "your_bot_token",
      "TelegramChatId": "your_chat_id",
      "NotifyOnSignalReceived": true,
      "NotifyOnPositionOpened": true,
      "NotifyOnTargetHit": true,
      "NotifyOnPositionClosed": true,
      "NotifyOnError": true
    },

    "State": {
      "StatePath": "signalbot_state.json",
      "BackupEnabled": true,
      "AutoSaveIntervalSeconds": 30
    }
  },

  "BinanceApi": {
    "UseTestnet": true,
    "ApiKey": "",
    "ApiSecret": ""
  },

  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "SignalBot": "Debug"
    }
  }
}
```

### ĞŸĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ (.env)

```bash
# Telegram API (https://my.telegram.org)
TELEGRAM_API_ID=12345678
TELEGRAM_API_HASH=your_api_hash
TELEGRAM_PHONE=+1234567890

# Telegram Bot Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
TELEGRAM_BOT_TOKEN=your_bot_token
TELEGRAM_CHAT_ID=your_chat_id

# Binance Futures Testnet
BINANCE_TESTNET_KEY=your_testnet_key
BINANCE_TESTNET_SECRET=your_testnet_secret

# Binance Futures Mainnet
BINANCE_MAINNET_KEY=your_mainnet_key
BINANCE_MAINNET_SECRET=your_mainnet_secret

# Mode
TRADING_BinanceApi__UseTestnet=true
```

---

## Multi-Assets Mode (USDC/USDT Ğ¾Ğ±Ñ‰Ğ°Ñ Ğ¼Ğ°Ñ€Ğ¶Ğ°)

ĞĞ¸Ğ¶Ğµ â€” Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ»Ğ°Ğ½, ĞºĞ°Ğº Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Multi-Assets Mode Ğ² SignalBot, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ°Ñ‚ÑŒ USDTâ€‘ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°Ğ¼Ğ¸ Ğ¿Ñ€Ğ¸ Ğ¼Ğ°Ñ€Ğ¶Ğµ Ğ¸Ğ· USDC (Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ ĞºĞ¾Ğ»Ğ»Ğ°Ñ‚ĞµÑ€Ğ°Ğ»ÑŒ). ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ¸Ğ´ĞµÑ: Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºÑƒ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğ°, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ‚ÑŒ ĞµĞ³Ğ¾ Ñ‡ĞµÑ€ĞµĞ· Binance USDâ“ˆâ€‘M API Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ñ‰ÑƒÑ Ğ¼Ğ°Ñ€Ğ¶Ñƒ/ÑĞºĞ²Ğ¸Ñ‚Ğ¸ Ğ¿Ñ€Ğ¸ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğµ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°, Ğ° Ğ½Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ `USDT`â€‘Ğ±Ğ°Ğ»Ğ°Ğ½Ñ. ĞšĞ¾Ğ´Ğ¾Ğ²Ñ‹Ğµ Ñ‚Ğ¾Ñ‡ĞºĞ¸ Ğ²Ñ…Ğ¾Ğ´Ğ° â€” Ğ² `SignalBot/Configuration/TradingSettings.cs`, `SignalBot/SignalBotRunner.cs`, `TradingBot.Binance/Futures/Interfaces/IBinanceFuturesClient.cs`, `TradingBot.Binance/Futures/BinanceFuturesClient.cs`.

### 1) Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğ°

**Ğ“Ğ´Ğµ:** `SignalBot/Configuration/TradingSettings.cs`  
**Ğ§Ñ‚Ğ¾:** Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„Ğ»Ğ°Ğ³ `EnableMultiAssetsMode` Ğ¸ Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ `MultiAssetsBalanceMode` (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, `TotalWallet`/`AvailableBalance`), Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ±Ğ¸Ñ€Ğ°Ñ‚ÑŒ, ĞºĞ°ĞºĞ¾Ğ¹ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¸ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ (Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼):

```csharp
public class TradingSettings
{
    public bool EnableMultiAssetsMode { get; set; } = false;
    public string MultiAssetsBalanceMode { get; set; } = "AvailableBalance";
}
```

Ğ˜ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ¾ Ğ² `appsettings.json` (ÑĞµĞºÑ†Ğ¸Ñ `SignalBot:Trading`):

```json
"EnableMultiAssetsMode": false,
"MultiAssetsBalanceMode": "AvailableBalance"
```

### 2) Ğ’ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Multi-Assets Mode Ñ‡ĞµÑ€ĞµĞ· Binance API

**API Binance USDâ“ˆâ€‘M:** `POST /fapi/v1/multiAssetsMargin` (Change Multi-Assets Mode).  
**Ğ“Ğ´Ğµ:** `TradingBot.Binance/Futures/Interfaces/IBinanceFuturesClient.cs` Ğ¸ `TradingBot.Binance/Futures/BinanceFuturesClient.cs`.

Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´:

```csharp
Task<bool> SetMultiAssetsModeAsync(bool enabled, CancellationToken ct = default);
```

Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ² `BinanceFuturesClient` (Binance.Net Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´ ÑƒÑ€Ğ¾Ğ²Ğ½Ñ `Account.ChangeMultiAssetsModeAsync`):

```csharp
public async Task<bool> SetMultiAssetsModeAsync(bool enabled, CancellationToken ct = default)
{
    var result = await _client.UsdFuturesApi.Account.ChangeMultiAssetsModeAsync(enabled, ct: ct);
    if (!result.Success)
    {
        _logger.Error("Failed to set Multi-Assets mode: {Error}", result.Error?.Message);
        return false;
    }

    _logger.Information("Multi-Assets mode set to {Enabled}", enabled);
    return true;
}
```

Ğ˜ Ğ²Ñ‹Ğ·Ğ¾Ğ² Ğ² `SignalBot/SignalBotRunner.StartAsync` Ğ¿ĞµÑ€ĞµĞ´ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ¾Ğ¼ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ğ¸:

```csharp
if (_settings.Trading.EnableMultiAssetsMode)
{
    var enabled = await _client.SetMultiAssetsModeAsync(true, _cts.Token);
    if (!enabled)
    {
        throw new InvalidOperationException("Failed to enable Multi-Assets Mode");
    }
}
```

### 3) Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ Ğ¸ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ‚Ğ¾Ñ€: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ ĞºĞ¾Ğ»Ğ»Ğ°Ñ‚ĞµÑ€Ğ°Ğ»ÑŒ

Ğ¡ĞµĞ¹Ñ‡Ğ°Ñ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ±ĞµÑ€Ñ‘Ñ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· `GetBalanceAsync(quoteCurrency)` â€” ÑÑ‚Ğ¾ `USDT` Ğ¸ Ğ¿Ñ€Ğ¸ USDCâ€‘Ğ¼Ğ°Ñ€Ğ¶Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ½Ğ¾Ğ»ÑŒ. ĞÑƒĞ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ² USDâ“ˆâ€‘M:

**API Binance USDâ“ˆâ€‘M:** `GET /fapi/v2/account`  
**Ğ“Ğ´Ğµ:** `TradingBot.Binance/Futures/BinanceFuturesClient.cs`, `SignalBot/SignalBotRunner.cs`.

Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Ğ¸ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ:

```csharp
Task<FuturesAccountInfo> GetAccountInfoAsync(CancellationToken ct = default);
```

ĞŸÑĞµĞ²Ğ´Ğ¾â€‘Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² `SignalBotRunner.TryValidateSignalAsync`:

```csharp
decimal balance;
if (_settings.Trading.EnableMultiAssetsMode)
{
    var account = await _client.GetAccountInfoAsync(_cts.Token);
    balance = _settings.Trading.MultiAssetsBalanceMode == "TotalWallet"
        ? account.TotalWalletBalance
        : account.AvailableBalance;
}
else
{
    var quoteCurrency = _settings.Trading.DefaultSymbolSuffix?.Trim().ToUpperInvariant() ?? "USDT";
    balance = await _client.GetBalanceAsync(quoteCurrency, _cts.Token);
}
```

### 4) ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ EEA/MiCA (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)

Ğ•ÑĞ»Ğ¸ USDTâ€‘Ñ„ÑŒÑÑ‡ĞµÑ€ÑÑ‹ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½Ñ‹ Ğ´Ğ»Ñ EEA, Multiâ€‘Assets Ğ½Ğµ Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµÑ‚ â€” Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ USDTâ€‘ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñ‹ Ğ½Ğ° ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸:

**Ğ“Ğ´Ğµ:** `SignalBot/SignalBotRunner.cs` (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, Ğ² `EnsureExecutionSymbolSupportedAsync` Ğ¸Ğ»Ğ¸ `NormalizeSignalSymbol`).  
**ĞšĞ°Ğº:** Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ñ„Ğ»Ğ°Ğ³ `DisallowUsdtFuturesInEea` Ğ² `TradingSettings` Ğ¸ Ğ¾Ñ‚ĞºĞ°Ğ· Ğ² Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ğ¿Ñ€Ğ¸ ÑÑƒÑ„Ñ„Ğ¸ĞºÑĞµ `USDT`.

---

## ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹

### SignalParser

```csharp
public class SignalParser
{
    // ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ regex Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€ÑĞ¸Ğ½Ğ³Ğ°
    private static readonly Regex SignalRegex = new(
        @"#(?<symbol>\w+)/USDT\s*-\s*(?<direction>Long|Short)[ğŸŸ¢ğŸ”´]?\s*" +
        @"Entry:\s*(?<entry>[\d.]+)\s*" +
        @"Stop\s*Loss:\s*(?<sl>[\d.]+)\s*" +
        @"(?:Target\s*1:\s*(?<t1>[\d.]+)\s*)?" +
        @"(?:Target\s*2:\s*(?<t2>[\d.]+)\s*)?" +
        @"(?:Target\s*3:\s*(?<t3>[\d.]+)\s*)?" +
        @"(?:Target\s*4:\s*(?<t4>[\d.]+)\s*)?" +
        @"Leverage:\s*x(?<leverage>\d+)",
        RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled);

    public SignalParserResult Parse(string text)
    {
        var match = SignalRegex.Match(text);

        if (!match.Success)
            return SignalParserResult.Failed("Signal format not recognized");

        var targets = new List<decimal>();
        for (int i = 1; i <= 4; i++)
        {
            var group = match.Groups[$"t{i}"];
            if (group.Success && decimal.TryParse(group.Value,
                NumberStyles.Any, CultureInfo.InvariantCulture, out var target))
            {
                targets.Add(target);
            }
        }

        return SignalParserResult.Success(new TradingSignal
        {
            RawText = text,
            Symbol = match.Groups["symbol"].Value.ToUpperInvariant() + "USDT",
            Direction = match.Groups["direction"].Value.Equals("Long",
                StringComparison.OrdinalIgnoreCase)
                    ? SignalDirection.Long
                    : SignalDirection.Short,
            Entry = decimal.Parse(match.Groups["entry"].Value, CultureInfo.InvariantCulture),
            OriginalStopLoss = decimal.Parse(match.Groups["sl"].Value, CultureInfo.InvariantCulture),
            Targets = targets,
            OriginalLeverage = int.Parse(match.Groups["leverage"].Value)
        });
    }
}
```

### SignalValidator

```csharp
public class SignalValidator : ISignalValidator
{
    private readonly RiskOverrideSettings _settings;
    private readonly IBinanceFuturesClient _client;

    public async Task<ValidationResult> ValidateAndAdjustAsync(
        TradingSignal signal,
        decimal accountEquity,
        CancellationToken ct = default)
    {
        var warnings = new List<string>();

        // 1. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°
        var symbolInfo = await _client.GetSymbolInfoAsync(signal.Symbol, ct);
        if (symbolInfo == null)
            return ValidationResult.Failed($"Symbol {signal.Symbol} not found");

        // 2. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ leverage
        int leverage = _settings.UseSignalLeverage
            ? Math.Min(signal.OriginalLeverage, _settings.MaxLeverage)
            : _settings.MaxLeverage;

        if (leverage != signal.OriginalLeverage)
            warnings.Add($"Leverage adjusted: {signal.OriginalLeverage}x â†’ {leverage}x");

        // 3. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ñ†ĞµĞ½Ñƒ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
        decimal liquidationPrice = CalculateLiquidationPrice(
            signal.Entry,
            signal.Direction,
            leverage);

        // 4. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Stop Loss
        decimal stopLoss;

        if (_settings.StopLossMode == StopLossMode.FromSignal)
        {
            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‡Ñ‚Ğ¾ SL Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶Ğ¸Ğ¼ Ğ´Ğ¾ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
            bool slIsValid = signal.Direction == SignalDirection.Long
                ? signal.OriginalStopLoss > liquidationPrice
                : signal.OriginalStopLoss < liquidationPrice;

            if (slIsValid)
            {
                stopLoss = signal.OriginalStopLoss;
            }
            else
            {
                stopLoss = CalculateSafeStopLoss(signal.Entry, liquidationPrice, signal.Direction);
                warnings.Add($"SL unreachable (liquidation first), adjusted to {stopLoss}");
            }
        }
        else // Calculate
        {
            stopLoss = CalculateSafeStopLoss(signal.Entry, liquidationPrice, signal.Direction);
            warnings.Add($"SL calculated: {stopLoss} (signal SL ignored: {signal.OriginalStopLoss})");
        }

        // 5. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ R:R
        decimal targetPrice = signal.Targets.FirstOrDefault();
        decimal riskReward = targetPrice > 0
            ? CalculateRiskReward(signal.Entry, stopLoss, targetPrice, signal.Direction)
            : 0;

        if (riskReward < 1.0m && riskReward > 0)
            warnings.Add($"Poor Risk:Reward ratio: {riskReward:F2}");

        // 6. ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        // (Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ¾ Ğ¿Ñ€Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ğ¸)

        return ValidationResult.Success(signal with
        {
            AdjustedStopLoss = stopLoss,
            AdjustedLeverage = leverage,
            LiquidationPrice = liquidationPrice,
            RiskRewardRatio = riskReward,
            IsValid = true,
            ValidationWarnings = warnings
        });
    }

    private decimal CalculateLiquidationPrice(decimal entry, SignalDirection direction, int leverage)
    {
        // Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ°Ñ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ° (Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ margin type, maintenance margin, etc.)
        decimal liquidationDistance = entry / leverage;

        return direction == SignalDirection.Long
            ? entry - liquidationDistance * 0.98m  // ~2% buffer
            : entry + liquidationDistance * 0.98m;
    }

    private decimal CalculateSafeStopLoss(decimal entry, decimal liquidationPrice, SignalDirection direction)
    {
        // SL Ğ½Ğ° 30% Ñ€Ğ°ÑÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ Ğ¾Ñ‚ entry Ğ´Ğ¾ liquidation
        decimal distance = Math.Abs(entry - liquidationPrice);
        decimal safeDistance = distance * _settings.SafeDistanceFromLiquidation;

        return direction == SignalDirection.Long
            ? entry - safeDistance
            : entry + safeDistance;
    }

    private decimal CalculateRiskReward(decimal entry, decimal stopLoss, decimal target, SignalDirection direction)
    {
        decimal risk = Math.Abs(entry - stopLoss);
        decimal reward = Math.Abs(target - entry);

        return risk > 0 ? reward / risk : 0;
    }
}
```

### SignalTrader

```csharp
public class SignalTrader : ISignalTrader
{
    private readonly IBinanceFuturesClient _client;
    private readonly IPositionManager _positionManager;
    private readonly IRiskManager _riskManager;
    private readonly TradingSettings _settings;
    private readonly ILogger<SignalTrader> _logger;

    public async Task<SignalPosition> ExecuteSignalAsync(
        TradingSignal signal,
        decimal accountEquity,
        CancellationToken ct = default)
    {
        // 1. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ² ÑÑ‚Ğ°Ñ‚ÑƒÑĞµ Pending
        var position = new SignalPosition
        {
            SignalId = signal.Id,
            Symbol = signal.Symbol,
            Direction = signal.Direction,
            Status = PositionStatus.Pending,
            PlannedEntryPrice = signal.Entry,
            CurrentStopLoss = signal.AdjustedStopLoss,
            Leverage = signal.AdjustedLeverage,
            Targets = CreateTargetLevels(signal)
        };

        await _positionManager.SavePositionAsync(position, ct);

        try
        {
            // 2. Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ leverage
            await _client.SetLeverageAsync(signal.Symbol, signal.AdjustedLeverage, ct);
            await _client.SetMarginTypeAsync(signal.Symbol, MarginType.Isolated, ct);

            // 3. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
            var positionSize = _riskManager.CalculatePositionSize(
                accountEquity,
                signal.Entry,
                signal.AdjustedStopLoss);

            position = position with
            {
                InitialQuantity = positionSize.Quantity,
                RemainingQuantity = positionSize.Quantity,
                Status = PositionStatus.Opening
            };
            await _positionManager.SavePositionAsync(position, ct);

            // 4. ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ (Market order)
            var entryOrder = await _client.PlaceMarketOrderAsync(new OrderRequest
            {
                Symbol = signal.Symbol,
                Side = signal.Direction == SignalDirection.Long ? OrderSide.Buy : OrderSide.Sell,
                Quantity = positionSize.Quantity
            }, ct);

            if (!entryOrder.IsSuccess)
            {
                position = position with { Status = PositionStatus.Failed };
                await _positionManager.SavePositionAsync(position, ct);
                throw new TradingException($"Entry order failed: {entryOrder.Error}");
            }

            position = position with
            {
                EntryOrderId = entryOrder.OrderId,
                ActualEntryPrice = entryOrder.AveragePrice,
                OpenedAt = DateTime.UtcNow,
                Status = PositionStatus.Open
            };

            // 5. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Stop Loss
            var slOrder = await _client.PlaceStopMarketOrderAsync(new OrderRequest
            {
                Symbol = signal.Symbol,
                Side = signal.Direction == SignalDirection.Long ? OrderSide.Sell : OrderSide.Buy,
                Quantity = positionSize.Quantity,
                StopPrice = signal.AdjustedStopLoss,
                ReduceOnly = true
            }, ct);

            position = position with { StopLossOrderId = slOrder.OrderId };

            // 6. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Take Profit Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
            var tpOrderIds = new List<long>();
            foreach (var target in position.Targets)
            {
                var tpOrder = await _client.PlaceTakeProfitMarketOrderAsync(new OrderRequest
                {
                    Symbol = signal.Symbol,
                    Side = signal.Direction == SignalDirection.Long ? OrderSide.Sell : OrderSide.Buy,
                    Quantity = target.QuantityToClose,
                    StopPrice = target.Price,
                    ReduceOnly = true
                }, ct);

                tpOrderIds.Add(tpOrder.OrderId);
            }

            position = position with { TakeProfitOrderIds = tpOrderIds };
            await _positionManager.SavePositionAsync(position, ct);

            _logger.LogInformation(
                "Position opened: {Symbol} {Direction} @ {Price}, SL: {SL}, Qty: {Qty}",
                position.Symbol, position.Direction, position.ActualEntryPrice,
                position.CurrentStopLoss, position.InitialQuantity);

            return position;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to execute signal {SignalId}", signal.Id);

            position = position with { Status = PositionStatus.Failed };
            await _positionManager.SavePositionAsync(position, ct);

            throw;
        }
    }

    private IReadOnlyList<TargetLevel> CreateTargetLevels(TradingSignal signal)
    {
        var targets = new List<TargetLevel>();
        var percents = _settings.TargetClosePercents;

        for (int i = 0; i < signal.Targets.Count && i < percents.Count; i++)
        {
            decimal moveSlTo = i == 0
                ? signal.Entry  // ĞŸĞ¾ÑĞ»Ğµ T1 Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ SL Ğ½Ğ° breakeven
                : signal.Targets[i - 1];  // ĞŸĞ¾ÑĞ»Ğµ T2 Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ Ğ½Ğ° T1, etc.

            targets.Add(new TargetLevel
            {
                Index = i,
                Price = signal.Targets[i],
                PercentToClose = percents[i],
                MoveStopLossTo = _settings.MoveStopToBreakeven ? moveSlTo : null
            });
        }

        return targets;
    }
}
```

### PositionManager

```csharp
public class PositionManager : IPositionManager
{
    private readonly IPositionStore<SignalPosition> _store;
    private readonly IBinanceFuturesClient _client;
    private readonly INotifier _notifier;
    private readonly ILogger<PositionManager> _logger;

    public async Task HandleTargetHitAsync(
        SignalPosition position,
        int targetIndex,
        decimal fillPrice,
        CancellationToken ct = default)
    {
        var target = position.Targets[targetIndex];

        // 1. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ target ĞºĞ°Ğº hit
        var updatedTargets = position.Targets.Select((t, i) => i == targetIndex
            ? t with { IsHit = true, HitAt = DateTime.UtcNow, ActualClosePrice = fillPrice }
            : t).ToList();

        // 2. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ remaining quantity
        decimal closedQty = target.QuantityToClose;
        decimal newRemaining = position.RemainingQuantity - closedQty;

        // 3. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ realized PnL Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚Ğ¸
        decimal pnl = CalculatePnl(
            position.ActualEntryPrice,
            fillPrice,
            closedQty,
            position.Direction);

        // 4. Ğ”Ğ²Ğ¸Ğ½ÑƒÑ‚ÑŒ Stop Loss ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾
        if (target.MoveStopLossTo.HasValue)
        {
            await MoveStopLossAsync(position, target.MoveStopLossTo.Value, newRemaining, ct);
        }

        // 5. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        var updatedPosition = position with
        {
            Targets = updatedTargets,
            RemainingQuantity = newRemaining,
            RealizedPnl = position.RealizedPnl + pnl,
            Status = newRemaining <= 0 ? PositionStatus.Closed : PositionStatus.PartialClosed,
            ClosedAt = newRemaining <= 0 ? DateTime.UtcNow : null,
            CloseReason = newRemaining <= 0 ? PositionCloseReason.AllTargetsHit : null
        };

        await _store.SavePositionAsync(updatedPosition, ct);

        // 6. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
        await _notifier.SendMessageAsync(
            $"ğŸ¯ Target {targetIndex + 1} hit!\n" +
            $"Symbol: {position.Symbol}\n" +
            $"Price: {fillPrice}\n" +
            $"PnL: {pnl:+0.00;-0.00} USDT\n" +
            $"Remaining: {newRemaining}",
            ct);

        _logger.LogInformation(
            "Target {Index} hit for {Symbol}: {Price}, PnL: {Pnl}",
            targetIndex + 1, position.Symbol, fillPrice, pnl);
    }

    public async Task HandleStopLossHitAsync(
        SignalPosition position,
        decimal fillPrice,
        CancellationToken ct = default)
    {
        // 1. ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ TP Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        foreach (var orderId in position.TakeProfitOrderIds)
        {
            await _client.CancelOrderAsync(position.Symbol, orderId, ct);
        }

        // 2. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ PnL
        decimal pnl = CalculatePnl(
            position.ActualEntryPrice,
            fillPrice,
            position.RemainingQuantity,
            position.Direction);

        // 3. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        var updatedPosition = position with
        {
            RemainingQuantity = 0,
            RealizedPnl = position.RealizedPnl + pnl,
            Status = PositionStatus.Closed,
            ClosedAt = DateTime.UtcNow,
            CloseReason = PositionCloseReason.StopLossHit
        };

        await _store.SavePositionAsync(updatedPosition, ct);

        // 4. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
        await _notifier.SendAlertAsync(
            "ğŸ›‘ Stop Loss Hit",
            $"Symbol: {position.Symbol}\n" +
            $"Entry: {position.ActualEntryPrice}\n" +
            $"Exit: {fillPrice}\n" +
            $"Total PnL: {updatedPosition.RealizedPnl:+0.00;-0.00} USDT",
            ct);
    }

    private async Task MoveStopLossAsync(
        SignalPosition position,
        decimal newStopLoss,
        decimal quantity,
        CancellationToken ct)
    {
        // 1. ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ SL
        if (position.StopLossOrderId.HasValue)
        {
            await _client.CancelOrderAsync(position.Symbol, position.StopLossOrderId.Value, ct);
        }

        // 2. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ SL
        var newSlOrder = await _client.PlaceStopMarketOrderAsync(new OrderRequest
        {
            Symbol = position.Symbol,
            Side = position.Direction == SignalDirection.Long ? OrderSide.Sell : OrderSide.Buy,
            Quantity = quantity,
            StopPrice = newStopLoss,
            ReduceOnly = true
        }, ct);

        _logger.LogInformation(
            "Stop loss moved for {Symbol}: {OldSL} â†’ {NewSL}",
            position.Symbol, position.CurrentStopLoss, newStopLoss);
    }

    private decimal CalculatePnl(decimal entry, decimal exit, decimal quantity, SignalDirection direction)
    {
        decimal priceDiff = direction == SignalDirection.Long
            ? exit - entry
            : entry - exit;

        return priceDiff * quantity;
    }
}
```

---

## Workflow

### ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SIGNAL PROCESSING FLOW                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram   â”‚
â”‚  Channel    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ New message
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram   â”‚     â”‚ Duplicate   â”‚
â”‚  Listener   â”‚â”€â”€â”€â”€â–¶â”‚ Check       â”‚â”€â”€â”€â”€ Already processed? â”€â”€â–¶ Skip
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Signal     â”‚â”€â”€â”€â”€ Parse failed? â”€â”€â–¶ Log warning, skip
â”‚  Parser     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ TradingSignal
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Signal     â”‚â”€â”€â”€â”€ Validation failed? â”€â”€â–¶ Notify, skip
â”‚  Validator  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Validated signal
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Concurrent  â”‚â”€â”€â”€â”€ Too many positions? â”€â”€â–¶ Queue or skip
â”‚ Position    â”‚
â”‚ Check       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Signal     â”‚â”€â”€â”€â”€ Order failed? â”€â”€â–¶ Notify error
â”‚  Trader     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Position opened
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Position   â”‚
â”‚  Manager    â”‚
â”‚  (monitor)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    POSITION CLOSE FLOW                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WebSocket  â”‚
â”‚  Order      â”‚
â”‚  Updates    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Order filled event
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Order      â”‚
â”‚  Monitor    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€ Stop Loss Order? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                                      â–¼
       â”‚                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                             â”‚ Handle SL   â”‚
       â”‚                             â”‚ - Cancel TPsâ”‚
       â”‚                             â”‚ - Calc PnL  â”‚
       â”‚                             â”‚ - Close pos â”‚
       â”‚                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â””â”€â”€â”€ Take Profit Order? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                              â–¼
                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                     â”‚ Handle TP   â”‚
                                     â”‚ - Update qtyâ”‚
                                     â”‚ - Move SL   â”‚
                                     â”‚ - Calc PnL  â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚                           â”‚
                              â–¼                           â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚ More targetsâ”‚            â”‚ All targets â”‚
                     â”‚ remaining   â”‚            â”‚ hit         â”‚
                     â”‚             â”‚            â”‚             â”‚
                     â”‚ Keep        â”‚            â”‚ Close       â”‚
                     â”‚ monitoring  â”‚            â”‚ position    â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Startup Ğ¸ Shutdown

### Startup Flow

```csharp
public class SignalBotRunner
{
    public async Task RunAsync(CancellationToken ct)
    {
        // 1. Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
        var state = await _stateManager.LoadStateAsync(ct);

        if (state != null)
        {
            _logger.LogInformation("Restored state: {Positions} open positions",
                state.OpenPositions.Count);

            // 2. Reconcile Ñ Ğ±Ğ¸Ñ€Ğ¶ĞµĞ¹
            var reconcileResult = await _reconciler.ReconcileAsync(state, ct);

            foreach (var mismatch in reconcileResult.PositionsMismatch)
            {
                _logger.LogWarning("Position mismatch: {Symbol} - local vs exchange",
                    mismatch.Symbol);
            }

            // 3. Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
            foreach (var position in reconcileResult.PositionsConfirmed)
            {
                await _positionManager.StartMonitoringAsync(position, ct);
            }
        }

        // 4. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ
        var account = await _client.GetAccountInfoAsync(ct);
        _logger.LogInformation("Account balance: {Balance} USDT", account.Balance);

        // 5. ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Telegram
        await _telegramListener.ConnectAsync(ct);

        // 6. ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ½Ğ° WebSocket Ğ´Ğ»Ñ order updates
        await _orderMonitor.StartAsync(ct);

        // 7. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
        await _telegramListener.StartListeningAsync(OnSignalReceived, ct);

        _logger.LogInformation("SignalBot started successfully");

        // 8. Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ
        await ct.WhenCanceled();
    }
}
```

### Shutdown Flow

```csharp
public async Task ShutdownAsync(ShutdownAction action, CancellationToken ct)
{
    _logger.LogInformation("Initiating shutdown with action: {Action}", action);

    // 1. ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ñ‘Ğ¼ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
    await _telegramListener.StopListeningAsync(ct);

    // 2. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    await _stateManager.SaveStateAsync(BuildCurrentState(), ct);

    // 3. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ
    switch (action)
    {
        case ShutdownAction.KeepPositionsAndOrders:
            // ĞĞ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµĞ¼ - Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¸ Ğ¾Ñ€Ğ´ĞµÑ€Ğ° Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ Ğ½Ğ° Ğ±Ğ¸Ñ€Ğ¶Ğµ
            break;

        case ShutdownAction.ClosePositions:
            foreach (var position in _openPositions)
            {
                await ClosePositionAtMarketAsync(position, ct);
            }
            break;

        case ShutdownAction.CancelOrdersKeepPositions:
            // ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ SL/TP, Ğ½Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ (ĞĞŸĞĞ¡ĞĞ!)
            foreach (var position in _openPositions)
            {
                await CancelAllOrdersAsync(position, ct);
            }
            break;
    }

    // 4. ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ñ‚ WebSocket
    await _orderMonitor.StopAsync(ct);

    // 5. ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ñ‚ Telegram
    await _telegramListener.DisconnectAsync(ct);

    // 6. Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ
    await _stateManager.SaveStateAsync(BuildCurrentState(), ct);

    // 7. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
    await _notifier.SendMessageAsync(
        $"ğŸ”´ SignalBot shutdown\nAction: {action}\nPositions: {_openPositions.Count}",
        ct);
}
```

---

## Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

### NuGet Ğ¿Ğ°ĞºĞµÑ‚Ñ‹

```xml
<ItemGroup>
  <!-- Telegram -->
  <PackageReference Include="WTelegramClient" Version="4.0.0" />

  <!-- Logging -->
  <PackageReference Include="Serilog" Version="3.1.1" />
  <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
  <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />

  <!-- Configuration -->
  <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
  <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
  <PackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="8.0.0" />
  <PackageReference Include="DotNetEnv" Version="3.0.0" />

  <!-- CLI -->
  <PackageReference Include="Spectre.Console" Version="0.49.1" />
</ItemGroup>

<ItemGroup>
  <ProjectReference Include="..\TradingBot.Core\TradingBot.Core.csproj" />
  <ProjectReference Include="..\TradingBot.Binance\TradingBot.Binance.csproj" />
</ItemGroup>
```

---

## Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

### Unit Tests

```
SignalBot.Tests/
â”œâ”€â”€ Parsing/
â”‚   â”œâ”€â”€ SignalParserTests.cs           # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ²
â”‚   â””â”€â”€ SignalParserEdgeCasesTests.cs  # Edge cases, Ğ½ĞµĞ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹
â”‚
â”œâ”€â”€ Validation/
â”‚   â”œâ”€â”€ SignalValidatorTests.cs        # Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
â”‚   â””â”€â”€ LiquidationCalculatorTests.cs  # Ğ Ğ°ÑÑ‡Ñ‘Ñ‚ Ñ†ĞµĞ½Ñ‹ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
â”‚
â”œâ”€â”€ Trading/
â”‚   â”œâ”€â”€ SignalTraderTests.cs           # Mock Binance client
â”‚   â””â”€â”€ PositionManagerTests.cs        # Target hit, SL hit scenarios
â”‚
â””â”€â”€ State/
    â””â”€â”€ StateRecoveryTests.cs          # Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ restart
```

### Integration Tests

```
SignalBot.Integration/
â”œâ”€â”€ TelegramListenerTests.cs           # Ğ ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº TG
â”œâ”€â”€ BinanceFuturesTests.cs             # Testnet trading
â””â”€â”€ EndToEndTests.cs                   # ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» ÑĞ¸Ğ³Ğ½Ğ°Ğ» â†’ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ â†’ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
```

---

## ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¸ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸

### Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

```
[2024-01-15 10:30:15 INF] Signal received from channel "CryptoSignals"
[2024-01-15 10:30:15 INF] Parsed signal: ICNTUSDT Long @ 0.3709
[2024-01-15 10:30:15 WRN] SL adjusted: 0.18569 â†’ 0.3593 (original unreachable)
[2024-01-15 10:30:15 WRN] Leverage adjusted: 32x â†’ 10x (max limit)
[2024-01-15 10:30:16 INF] Position opened: ICNTUSDT Long @ 0.3710, Qty: 100
[2024-01-15 10:30:16 INF] SL order placed: 12345 @ 0.3593
[2024-01-15 10:30:16 INF] TP orders placed: 12346, 12347, 12348, 12349
[2024-01-15 10:45:30 INF] Target 1 hit: ICNTUSDT @ 0.37225, PnL: +1.35 USDT
[2024-01-15 10:45:30 INF] SL moved: 0.3593 â†’ 0.3709 (breakeven)
```

### Telegram ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ

```
ğŸ“¥ Signal Received
Symbol: ICNTUSDT
Direction: Long
Entry: 0.3709
Adjusted SL: 0.3593 (was 0.18569)
Targets: 0.37225, 0.37243, 0.37362, 0.37452
Leverage: 10x (was 32x)

---

âœ… Position Opened
Symbol: ICNTUSDT Long
Entry: 0.3710
Quantity: 100
Stop Loss: 0.3593
Risk: 1.0% ($10.00)

---

ğŸ¯ Target 1 Hit!
Symbol: ICNTUSDT
Price: 0.37225
Closed: 25 (25%)
PnL: +1.35 USDT
SL moved to: 0.3709 (breakeven)

---

ğŸ›‘ Stop Loss Hit
Symbol: ICNTUSDT
Entry: 0.3710
Exit: 0.3593
Total PnL: -3.51 USDT
```

---

## ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€ÑƒÑÑ‰Ğ¸Ñ…ÑÑ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²

### ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°

Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ, ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ, Ğ¿Ğ¾ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼Ñƒ ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ?

### Ğ ĞµĞ¶Ğ¸Ğ¼Ñ‹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ (DuplicateSignalHandling)

```csharp
public enum DuplicateSignalHandling
{
    /// <summary>
    /// Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ», Ğ¿Ğ¾ĞºĞ° ĞµÑÑ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
    /// </summary>
    Ignore,

    /// <summary>
    /// ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ (DCA/pyramid)
    /// </summary>
    OpenNew,

    /// <summary>
    /// ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ targets Ğ¸ SL ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    /// </summary>
    UpdateTargets,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ
    /// </summary>
    CloseAndReopen
}
```

### Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸

```
                         ĞĞ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½
                                â”‚
                                â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Ğ•ÑÑ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ â”‚
                    â”‚    Ğ¿Ğ¾ ÑÑ‚Ğ¾Ğ¼Ñƒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ?  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                       â”‚
                   ĞĞµÑ‚                     Ğ”Ğ°
                    â”‚                       â”‚
                    â–¼                       â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ  â”‚       â”‚ ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚â”‚
              â”‚ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ  â”‚       â”‚ (Long â†’ Long)?      â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚                           â”‚
                             Ğ”Ğ°                          ĞĞµÑ‚
                              â”‚                           â”‚
                              â–¼                           â–¼
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼    â”‚      â”‚ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼    â”‚
                 â”‚ DuplicateHandling  â”‚      â”‚ OppositeSignal     â”‚
                 â”‚ Ğ´Ğ»Ñ same-direction â”‚      â”‚ Handling           â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° (OppositeSignalHandling)

```csharp
public enum OppositeSignalHandling
{
    /// <summary>
    /// Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ»
    /// </summary>
    Ignore,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ğ½Ğ¾ Ğ½Ğµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ
    /// </summary>
    CloseOnly,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ² Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸
    /// </summary>
    Reverse
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ignore (ĞºĞ¾Ğ½ÑĞµÑ€Ğ²Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ BTCUSDT
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long (Ğ½Ğ¾Ğ²Ñ‹Ğµ targets)
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:  Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼, Ğ»Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ "Signal ignored: position already open"
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: OpenNew (DCA/ÑƒÑÑ€ĞµĞ´Ğ½ĞµĞ½Ğ¸Ğµ)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ BTCUSDT @ 50000, qty: 0.1
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long @ 48000 (Ñ†ĞµĞ½Ğ° ÑƒĞ¿Ğ°Ğ»Ğ°)
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:  ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²Ñ‚Ğ¾Ñ€ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ, Ñ‚ĞµĞ¿ĞµÑ€ÑŒ 2 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ BTC
Ğ Ğ¸ÑĞº:      Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ĞµĞ½Ğ½Ğ°Ñ ÑĞºÑĞ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ½Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ğ°ĞºÑ‚Ğ¸Ğ²
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: UpdateTargets (Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long BTCUSDT, SL: 49000, Targets: [51000, 52000]
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long, SL: 49500, Targets: [51500, 52500]
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:
  1. ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ SL/TP Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
  2. Ğ Ğ°Ğ·Ğ¼ĞµÑ‰Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğµ SL: 49500, TP: [51500, 52500]
  3. ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ SignalPosition
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 4: CloseAndReopen**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long BTCUSDT @ 50000 (Ğ² Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¼ Ğ¼Ğ¸Ğ½ÑƒÑĞµ)
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Long @ 49500 (Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ñ…Ğ¾Ğ´)
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:
  1. Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ
  2. Ğ¤Ğ¸ĞºÑĞ¸Ñ€ÑƒĞµĞ¼ P&L
  3. ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñƒ
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 5: Reverse (Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ»)**
```
Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ: ĞÑ‚ĞºÑ€Ñ‹Ñ‚Ğ° Long BTCUSDT @ 50000
ĞŸÑ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚:  #BTC/USDT - Short @ 49000
Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ (Ğ¿Ñ€Ğ¸ OppositeSignalHandling.Reverse):
  1. Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Long Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
  2. ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Short Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

```json
{
  "SignalBot": {
    "DuplicateHandling": {
      "SameDirection": "Ignore",
      "OppositeDirection": "Ignore",
      "MaxPositionsPerSymbol": 1,
      "MinTimeBetweenDuplicates": "00:05:00",
      "AllowDuplicateOnPartialClose": true
    }
  }
}
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº

```csharp
public record DuplicateHandlingSettings
{
    /// <summary>
    /// Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ» ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ² Ñ‚Ğ¾Ğ¼ Ğ¶Ğµ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸
    /// </summary>
    public DuplicateSignalHandling SameDirection { get; init; } = DuplicateSignalHandling.Ignore;

    /// <summary>
    /// Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ» ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ² Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ²Ğ¾Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ½Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸
    /// </summary>
    public OppositeSignalHandling OppositeDirection { get; init; } = OppositeSignalHandling.Ignore;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ (Ğ´Ğ»Ñ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğ° OpenNew)
    /// </summary>
    public int MaxPositionsPerSymbol { get; init; } = 1;

    /// <summary>
    /// ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ°Ğ¼Ğ¸
    /// </summary>
    public TimeSpan MinTimeBetweenDuplicates { get; init; } = TimeSpan.FromMinutes(5);

    /// <summary>
    /// Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚ ĞµÑĞ»Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ° (Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚Ñ‹ targets)
    /// </summary>
    public bool AllowDuplicateOnPartialClose { get; init; } = true;
}
```

### Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ² SignalProcessor

```csharp
public class SignalProcessor
{
    private readonly DuplicateHandlingSettings _duplicateSettings;
    private readonly IPositionStore _positionStore;

    public async Task<SignalProcessingResult> ProcessSignalAsync(
        TradingSignal signal,
        CancellationToken ct = default)
    {
        // 1. ĞĞ°Ğ¹Ñ‚Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñƒ
        var existingPositions = await _positionStore.GetOpenPositionsBySymbolAsync(signal.Symbol, ct);

        if (!existingPositions.Any())
        {
            // ĞĞµÑ‚ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹ - Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°
            return await ExecuteNewSignalAsync(signal, ct);
        }

        // 2. ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹
        var existingDirection = existingPositions.First().Direction;
        bool isSameDirection = existingDirection == signal.Direction;

        if (isSameDirection)
        {
            return await HandleSameDirectionDuplicateAsync(signal, existingPositions, ct);
        }
        else
        {
            return await HandleOppositeDirectionAsync(signal, existingPositions, ct);
        }
    }

    private async Task<SignalProcessingResult> HandleSameDirectionDuplicateAsync(
        TradingSignal signal,
        IReadOnlyList<SignalPosition> existingPositions,
        CancellationToken ct)
    {
        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»
        var lastPosition = existingPositions.OrderByDescending(p => p.CreatedAt).First();
        var timeSinceLastSignal = DateTime.UtcNow - lastPosition.CreatedAt;

        if (timeSinceLastSignal < _duplicateSettings.MinTimeBetweenDuplicates)
        {
            _logger.LogInformation(
                "Signal ignored: too soon after previous ({Elapsed} < {Min})",
                timeSinceLastSignal, _duplicateSettings.MinTimeBetweenDuplicates);
            return SignalProcessingResult.Skipped("Too soon after previous signal");
        }

        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
        bool hasPartialClose = existingPositions.Any(p => p.Status == PositionStatus.PartialClosed);
        if (hasPartialClose && _duplicateSettings.AllowDuplicateOnPartialClose)
        {
            _logger.LogInformation("Allowing duplicate signal due to partial close");
            return await ExecuteNewSignalAsync(signal, ct);
        }

        // ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
        return _duplicateSettings.SameDirection switch
        {
            DuplicateSignalHandling.Ignore =>
                SignalProcessingResult.Skipped("Position already open for symbol"),

            DuplicateSignalHandling.OpenNew when existingPositions.Count < _duplicateSettings.MaxPositionsPerSymbol =>
                await ExecuteNewSignalAsync(signal, ct),

            DuplicateSignalHandling.OpenNew =>
                SignalProcessingResult.Skipped($"Max positions ({_duplicateSettings.MaxPositionsPerSymbol}) reached"),

            DuplicateSignalHandling.UpdateTargets =>
                await UpdateExistingPositionAsync(existingPositions.First(), signal, ct),

            DuplicateSignalHandling.CloseAndReopen =>
                await CloseAndReopenAsync(existingPositions, signal, ct),

            _ => throw new ArgumentOutOfRangeException()
        };
    }

    private async Task<SignalProcessingResult> HandleOppositeDirectionAsync(
        TradingSignal signal,
        IReadOnlyList<SignalPosition> existingPositions,
        CancellationToken ct)
    {
        return _duplicateSettings.OppositeDirection switch
        {
            OppositeSignalHandling.Ignore =>
                SignalProcessingResult.Skipped("Opposite position already open"),

            OppositeSignalHandling.CloseOnly =>
                await CloseExistingPositionsAsync(existingPositions, "Opposite signal received", ct),

            OppositeSignalHandling.Reverse =>
                await ReversePositionAsync(existingPositions, signal, ct),

            _ => throw new ArgumentOutOfRangeException()
        };
    }

    private async Task<SignalProcessingResult> UpdateExistingPositionAsync(
        SignalPosition position,
        TradingSignal newSignal,
        CancellationToken ct)
    {
        _logger.LogInformation(
            "Updating existing position {PositionId} with new signal targets",
            position.Id);

        // 1. ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ SL/TP Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        await CancelPositionOrdersAsync(position, ct);

        // 2. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ targets
        var newTargets = CreateTargetLevels(newSignal, position.RemainingQuantity);

        // 3. Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
        var newSlOrderId = await PlaceStopLossOrderAsync(
            position.Symbol,
            position.Direction,
            position.RemainingQuantity,
            newSignal.AdjustedStopLoss,
            ct);

        var newTpOrderIds = await PlaceTakeProfitOrdersAsync(
            position.Symbol,
            position.Direction,
            newTargets,
            ct);

        // 4. ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
        var updatedPosition = position with
        {
            CurrentStopLoss = newSignal.AdjustedStopLoss,
            Targets = newTargets,
            StopLossOrderId = newSlOrderId,
            TakeProfitOrderIds = newTpOrderIds
        };

        await _positionStore.SavePositionAsync(updatedPosition, ct);

        return SignalProcessingResult.Success(updatedPosition, "Targets updated");
    }
}
```

---

## ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸

### Ğ ĞµĞ¶Ğ¸Ğ¼Ñ‹ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ° Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°

```csharp
public enum PositionSizingMode
{
    /// <summary>
    /// ĞŸÑ€Ğ¾Ñ†ĞµĞ½Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ´ Ñ€Ğ¸ÑĞº (Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ SL)
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: 1% Ñ€Ğ¸ÑĞºĞ° Ğ¿Ñ€Ğ¸ SL -5% = Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ 20% Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
    /// </summary>
    RiskPercent,

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ° Ğ² quote currency (USDT)
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ²ÑĞµĞ³Ğ´Ğ° Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ° $100
    /// </summary>
    FixedAmount,

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ margin Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ leverage
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: margin $50 Ğ¿Ñ€Ğ¸ leverage 10x = Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ $500
    /// </summary>
    FixedMargin,

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ base currency
    /// ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Ğ²ÑĞµĞ³Ğ´Ğ° Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ°Ñ‚ÑŒ 0.01 BTC
    /// </summary>
    FixedQuantity
}
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ Ñ override Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ğ¼

```json
{
  "SignalBot": {
    "PositionSizing": {
      "DefaultMode": "RiskPercent",
      "DefaultRiskPercent": 1.0,
      "DefaultFixedAmount": 100.0,
      "DefaultFixedMargin": 50.0,

      "SymbolOverrides": {
        "BTCUSDT": {
          "Mode": "FixedAmount",
          "FixedAmount": 200.0
        },
        "ETHUSDT": {
          "Mode": "FixedAmount",
          "FixedAmount": 150.0
        },
        "DOGEUSDT": {
          "Mode": "RiskPercent",
          "RiskPercent": 0.5
        },
        "*USDT": {
          "Mode": "FixedAmount",
          "FixedAmount": 50.0
        }
      },

      "Limits": {
        "MinPositionUsdt": 10.0,
        "MaxPositionUsdt": 1000.0,
        "MaxPositionPercent": 25.0,
        "MaxTotalExposurePercent": 80.0
      }
    }
  }
}
```

### ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº

```csharp
public record PositionSizingSettings
{
    /// <summary>
    /// Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
    /// </summary>
    public PositionSizingMode DefaultMode { get; init; } = PositionSizingMode.RiskPercent;

    /// <summary>
    /// ĞŸÑ€Ğ¾Ñ†ĞµĞ½Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ° Ğ¿Ğ¾Ğ´ Ñ€Ğ¸ÑĞº (Ğ´Ğ»Ñ RiskPercent)
    /// </summary>
    public decimal DefaultRiskPercent { get; init; } = 1.0m;

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ° Ğ² USDT (Ğ´Ğ»Ñ FixedAmount)
    /// </summary>
    public decimal DefaultFixedAmount { get; init; } = 100m;

    /// <summary>
    /// Ğ¤Ğ¸ĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ margin Ğ² USDT (Ğ´Ğ»Ñ FixedMargin)
    /// </summary>
    public decimal DefaultFixedMargin { get; init; } = 50m;

    /// <summary>
    /// Override Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ğ¼
    /// ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ wildcards: "BTCUSDT", "*USDT", "BTC*"
    /// </summary>
    public Dictionary<string, SymbolSizingOverride> SymbolOverrides { get; init; } = new();

    /// <summary>
    /// Ğ›Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸
    /// </summary>
    public PositionLimits Limits { get; init; } = new();
}

public record SymbolSizingOverride
{
    public PositionSizingMode? Mode { get; init; }
    public decimal? RiskPercent { get; init; }
    public decimal? FixedAmount { get; init; }
    public decimal? FixedMargin { get; init; }
    public decimal? FixedQuantity { get; init; }
    public decimal? MaxLeverage { get; init; }
}

public record PositionLimits
{
    /// <summary>
    /// ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ² USDT
    /// </summary>
    public decimal MinPositionUsdt { get; init; } = 10m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ² USDT
    /// </summary>
    public decimal MaxPositionUsdt { get; init; } = 1000m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºĞ°Ğº % Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
    /// </summary>
    public decimal MaxPositionPercent { get; init; } = 25m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ğ°Ñ ÑĞºÑĞ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞºĞ°Ğº % Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
    /// </summary>
    public decimal MaxTotalExposurePercent { get; init; } = 80m;
}
```

### ĞšĞ°Ğ»ÑŒĞºÑƒĞ»ÑÑ‚Ğ¾Ñ€ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸

```csharp
public class PositionSizeCalculator
{
    private readonly PositionSizingSettings _settings;
    private readonly ILogger<PositionSizeCalculator> _logger;

    public PositionSizeResult Calculate(
        string symbol,
        decimal entryPrice,
        decimal stopLoss,
        int leverage,
        decimal accountEquity,
        decimal currentExposure)
    {
        // 1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ´Ğ»Ñ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° (Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ override)
        var symbolSettings = GetSymbolSettings(symbol);

        // 2. Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€
        decimal positionValueUsdt = symbolSettings.Mode switch
        {
            PositionSizingMode.RiskPercent =>
                CalculateFromRisk(accountEquity, symbolSettings.RiskPercent, entryPrice, stopLoss),

            PositionSizingMode.FixedAmount =>
                symbolSettings.FixedAmount,

            PositionSizingMode.FixedMargin =>
                symbolSettings.FixedMargin * leverage,

            PositionSizingMode.FixedQuantity =>
                symbolSettings.FixedQuantity * entryPrice,

            _ => throw new ArgumentOutOfRangeException()
        };

        // 3. ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹
        var (adjustedValue, warnings) = ApplyLimits(
            positionValueUsdt,
            accountEquity,
            currentExposure);

        // 4. ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾
        decimal quantity = adjustedValue / entryPrice;

        return new PositionSizeResult
        {
            Quantity = quantity,
            PositionValueUsdt = adjustedValue,
            RequiredMargin = adjustedValue / leverage,
            RiskAmount = CalculateRiskAmount(adjustedValue, entryPrice, stopLoss),
            Mode = symbolSettings.Mode,
            Warnings = warnings
        };
    }

    private SymbolSizingOverride GetSymbolSettings(string symbol)
    {
        // 1. Ğ¢Ğ¾Ñ‡Ğ½Ğ¾Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ
        if (_settings.SymbolOverrides.TryGetValue(symbol, out var exact))
        {
            return MergeWithDefaults(exact);
        }

        // 2. Wildcard ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ğµ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ "*USDT", "BTC*")
        foreach (var (pattern, settings) in _settings.SymbolOverrides)
        {
            if (MatchesWildcard(symbol, pattern))
            {
                return MergeWithDefaults(settings);
            }
        }

        // 3. Defaults
        return new SymbolSizingOverride
        {
            Mode = _settings.DefaultMode,
            RiskPercent = _settings.DefaultRiskPercent,
            FixedAmount = _settings.DefaultFixedAmount,
            FixedMargin = _settings.DefaultFixedMargin
        };
    }

    private decimal CalculateFromRisk(
        decimal equity,
        decimal riskPercent,
        decimal entry,
        decimal stopLoss)
    {
        decimal riskAmount = equity * (riskPercent / 100m);
        decimal slDistance = Math.Abs(entry - stopLoss) / entry;

        if (slDistance <= 0)
        {
            _logger.LogWarning("Invalid SL distance, using default position size");
            return _settings.DefaultFixedAmount;
        }

        return riskAmount / slDistance;
    }

    private (decimal Value, List<string> Warnings) ApplyLimits(
        decimal positionValue,
        decimal equity,
        decimal currentExposure)
    {
        var warnings = new List<string>();
        var limits = _settings.Limits;
        decimal adjusted = positionValue;

        // ĞœĞ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼
        if (adjusted < limits.MinPositionUsdt)
        {
            warnings.Add($"Position below minimum ({adjusted:F2} < {limits.MinPositionUsdt}), adjusted up");
            adjusted = limits.MinPositionUsdt;
        }

        // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğ¹
        if (adjusted > limits.MaxPositionUsdt)
        {
            warnings.Add($"Position exceeds max ({adjusted:F2} > {limits.MaxPositionUsdt}), capped");
            adjusted = limits.MaxPositionUsdt;
        }

        // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ ĞºĞ°Ğº % Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°
        decimal maxByPercent = equity * (limits.MaxPositionPercent / 100m);
        if (adjusted > maxByPercent)
        {
            warnings.Add($"Position exceeds {limits.MaxPositionPercent}% of equity, capped to {maxByPercent:F2}");
            adjusted = maxByPercent;
        }

        // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¾Ğ±Ñ‰ĞµĞ¹ ÑĞºÑĞ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
        decimal maxExposure = equity * (limits.MaxTotalExposurePercent / 100m);
        decimal remainingExposure = maxExposure - currentExposure;

        if (adjusted > remainingExposure)
        {
            warnings.Add($"Total exposure limit reached, reduced to {remainingExposure:F2}");
            adjusted = Math.Max(0, remainingExposure);
        }

        return (adjusted, warnings);
    }

    private bool MatchesWildcard(string symbol, string pattern)
    {
        if (pattern.StartsWith("*"))
            return symbol.EndsWith(pattern.TrimStart('*'));

        if (pattern.EndsWith("*"))
            return symbol.StartsWith(pattern.TrimEnd('*'));

        return false;
    }
}

public record PositionSizeResult
{
    public decimal Quantity { get; init; }
    public decimal PositionValueUsdt { get; init; }
    public decimal RequiredMargin { get; init; }
    public decimal RiskAmount { get; init; }
    public PositionSizingMode Mode { get; init; }
    public IReadOnlyList<string> Warnings { get; init; } = [];
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ñ€Ğ°ÑÑ‡Ñ‘Ñ‚Ğ°

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 1: RiskPercent**
```
ĞšĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»: $10,000
RiskPercent: 1% ($100 Ñ€Ğ¸ÑĞºĞ°)
Entry: $50,000 (BTC)
Stop Loss: $48,000 (4% Ğ¾Ñ‚ entry)
Ğ Ğ°ÑÑ‡Ñ‘Ñ‚: $100 / 0.04 = $2,500 Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: $2,500 / $50,000 = 0.05 BTC
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 2: FixedAmount**
```
FixedAmount: $200
Entry: $50,000
ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: $200 / $50,000 = 0.004 BTC
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 3: FixedMargin**
```
FixedMargin: $50
Leverage: 10x
ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ: $50 * 10 = $500
Entry: $50,000
ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾: $500 / $50,000 = 0.01 BTC
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ 4: Symbol Override**
```
Config: BTCUSDT.FixedAmount = $200
        Default.FixedAmount = $100

Signal: BTCUSDT â†’ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ $200
Signal: ETHUSDT â†’ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ $100 (default)
```

---

## Entry Timing / Price Deviation

### ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°

Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ» Ñ Entry: 0.3709, Ğ½Ğ¾ Ğ¿Ğ¾ĞºĞ° Ğ¼Ñ‹ ĞµĞ³Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»Ğ¸, Ñ†ĞµĞ½Ğ° ÑƒĞ¶Ğµ 0.3750 (+1.1%). Ğ’Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ? Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ĞºÑƒ? ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ?

### ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸

```csharp
public record EntrySettings
{
    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹ Ğ¾Ñ‚ Entry Ğ´Ğ»Ñ Ğ²Ñ…Ğ¾Ğ´Ğ° Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ (%)
    /// Ğ•ÑĞ»Ğ¸ Ñ†ĞµĞ½Ğ° ÑƒÑˆĞ»Ğ° Ğ´Ğ°Ğ»ÑŒÑˆĞµ - Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ DeviationAction
    /// </summary>
    public decimal MaxPriceDeviationPercent { get; init; } = 0.5m;

    /// <summary>
    /// Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ ĞµÑĞ»Ğ¸ Ñ†ĞµĞ½Ğ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½Ğ¸Ğ»Ğ°ÑÑŒ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğ³Ğ¾
    /// </summary>
    public PriceDeviationAction DeviationAction { get; init; } = PriceDeviationAction.Skip;

    /// <summary>
    /// Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Limit Ğ¾Ñ€Ğ´ĞµÑ€ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Market Ğ´Ğ»Ñ Ğ²Ñ…Ğ¾Ğ´Ğ°
    /// </summary>
    public bool UseLimitOrder { get; init; } = false;

    /// <summary>
    /// Ğ¦ĞµĞ½Ğ° Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ€Ğ´ĞµÑ€Ğ° Ğ¾Ñ‚Ğ½Ğ¾ÑĞ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Entry
    /// </summary>
    public LimitOrderPricing LimitPricing { get; init; } = LimitOrderPricing.AtEntry;

    /// <summary>
    /// Ğ’Ñ€ĞµĞ¼Ñ Ğ¶Ğ¸Ğ·Ğ½Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ€Ğ´ĞµÑ€Ğ° Ğ¿ĞµÑ€ĞµĞ´ Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¾Ğ¹
    /// </summary>
    public TimeSpan LimitOrderTtl { get; init; } = TimeSpan.FromMinutes(5);

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ slippage Ğ¿Ñ€Ğ¸ Market Ğ¾Ñ€Ğ´ĞµÑ€Ğµ (%)
    /// </summary>
    public decimal MaxSlippagePercent { get; init; } = 0.3m;
}

public enum PriceDeviationAction
{
    /// <summary>
    /// ĞŸÑ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ
    /// </summary>
    Skip,

    /// <summary>
    /// Ğ’Ğ¾Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ Ğ½ĞµÑĞ¼Ğ¾Ñ‚Ñ€Ñ Ğ½Ğ° Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğµ
    /// </summary>
    EnterAtMarket,

    /// <summary>
    /// ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ½Ñ‹Ğ¹ Ğ¾Ñ€Ğ´ĞµÑ€ Ğ½Ğ° Ñ†ĞµĞ½Ñƒ Entry Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    /// </summary>
    PlaceLimitAtEntry,

    /// <summary>
    /// Ğ’Ğ¾Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ, Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ targets Ğ¿Ñ€Ğ¾Ğ¿Ğ¾Ñ€Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾
    /// </summary>
    EnterAndAdjustTargets
}

public enum LimitOrderPricing
{
    /// <summary>
    /// Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ĞºÑƒ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ½Ğ° Entry Ğ¸Ğ· ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    /// </summary>
    AtEntry,

    /// <summary>
    /// Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ĞºÑƒ Ğ½Ğ° Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ñ†ĞµĞ½Ñƒ (aggressive)
    /// </summary>
    AtCurrentPrice,

    /// <summary>
    /// Ğ¡Ñ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼ĞµĞ¶Ğ´Ñƒ Entry Ğ¸ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ Ñ†ĞµĞ½Ğ¾Ğ¹
    /// </summary>
    MidPoint
}
```

### Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸

```
                    ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ñ Entry price
                              â”‚
                              â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ    â”‚
                    â”‚ Ñ€Ñ‹Ğ½Ğ¾Ñ‡Ğ½ÑƒÑ Ñ†ĞµĞ½Ñƒ       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ deviation =         â”‚
                    â”‚ |current - entry|   â”‚
                    â”‚ / entry * 100%      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                                 â”‚
    deviation <= MaxDeviation          deviation > MaxDeviation
              â”‚                                 â”‚
              â–¼                                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ UseLimitOrder?  â”‚              â”‚ ĞŸÑ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚ DeviationAction     â”‚
             â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
     â”‚               â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    Yes             No               â”‚          â”‚          â”‚
     â”‚               â”‚               â–¼          â–¼          â–¼
     â–¼               â–¼             Skip    EnterAtMarket  PlaceLimit
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Place   â”‚   â”‚ Market   â”‚
â”‚ Limit   â”‚   â”‚ Order    â”‚
â”‚ Order   â”‚   â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞŸĞµÑ€ĞµÑÑ‡Ñ‘Ñ‚ targets Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğ¸

```csharp
public class TargetAdjuster
{
    /// <summary>
    /// ĞŸĞµÑ€ĞµÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ targets Ğ¿Ñ€Ğ¾Ğ¿Ğ¾Ñ€Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ñ†ĞµĞ½Ğµ Ğ²Ñ…Ğ¾Ğ´Ğ°
    /// </summary>
    public IReadOnlyList<decimal> AdjustTargets(
        decimal originalEntry,
        decimal actualEntry,
        IReadOnlyList<decimal> originalTargets,
        SignalDirection direction)
    {
        // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚ ÑĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ
        decimal shift = actualEntry - originalEntry;

        // Ğ”Ğ»Ñ Long: ĞµÑĞ»Ğ¸ Ğ²Ğ¾ÑˆĞ»Ğ¸ Ğ²Ñ‹ÑˆĞµ - targets Ñ‚Ğ¾Ğ¶Ğµ ÑĞ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ Ğ²Ñ‹ÑˆĞµ
        // Ğ”Ğ»Ñ Short: ĞµÑĞ»Ğ¸ Ğ²Ğ¾ÑˆĞ»Ğ¸ Ğ½Ğ¸Ğ¶Ğµ - targets Ñ‚Ğ¾Ğ¶Ğµ ÑĞ´Ğ²Ğ¸Ğ³Ğ°ĞµĞ¼ Ğ½Ğ¸Ğ¶Ğµ
        return originalTargets.Select(t => t + shift).ToList();
    }

    /// <summary>
    /// ĞĞ»ÑŒÑ‚ĞµÑ€Ğ½Ğ°Ñ‚Ğ¸Ğ²Ğ°: ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ R:R ratio
    /// </summary>
    public IReadOnlyList<decimal> AdjustTargetsKeepRatio(
        decimal originalEntry,
        decimal actualEntry,
        decimal originalSl,
        IReadOnlyList<decimal> originalTargets,
        SignalDirection direction)
    {
        decimal originalRisk = Math.Abs(originalEntry - originalSl);

        return originalTargets.Select(target =>
        {
            decimal originalReward = Math.Abs(target - originalEntry);
            decimal ratio = originalReward / originalRisk;

            decimal newRisk = Math.Abs(actualEntry - originalSl);
            decimal newReward = newRisk * ratio;

            return direction == SignalDirection.Long
                ? actualEntry + newReward
                : actualEntry - newReward;
        }).ToList();
    }
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 1: Ğ¦ĞµĞ½Ğ° Ğ² Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ñ… Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğ³Ğ¾**
```
Entry Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğµ: 0.3709
Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°:    0.3715 (+0.16%)
MaxDeviation:    0.5%
Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:       Ğ’Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ @ 0.3715
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 2: Ğ¦ĞµĞ½Ğ° ÑƒÑˆĞ»Ğ°, Skip**
```
Entry Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğµ: 0.3709
Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°:    0.3780 (+1.9%)
MaxDeviation:    0.5%
DeviationAction: Skip
Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:       Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½, Ğ»Ğ¾Ğ³: "Price deviation 1.9% > 0.5%"
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 3: Ğ¦ĞµĞ½Ğ° ÑƒÑˆĞ»Ğ°, PlaceLimitAtEntry**
```
Entry Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğµ: 0.3709
Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°:    0.3780 (+1.9%)
DeviationAction: PlaceLimitAtEntry
LimitOrderTtl:   5 Ğ¼Ğ¸Ğ½ÑƒÑ‚
Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:       Ğ›Ğ¸Ğ¼Ğ¸Ñ‚Ğ½Ñ‹Ğ¹ Ğ¾Ñ€Ğ´ĞµÑ€ @ 0.3709, Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· 5 Ğ¼Ğ¸Ğ½ ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑÑ
```

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ 4: Ğ¦ĞµĞ½Ğ° ÑƒÑˆĞ»Ğ°, AdjustTargets**
```
Entry Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğµ: 0.3709, Targets: [0.3725, 0.3750, 0.3780]
Ğ¢ĞµĞºÑƒÑ‰Ğ°Ñ Ñ†ĞµĞ½Ğ°:    0.3730 (+0.57%)
DeviationAction: EnterAndAdjustTargets

Shift: +0.0021
ĞĞ¾Ğ²Ñ‹Ğµ targets:   [0.3746, 0.3771, 0.3801]
Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:       Ğ’Ñ…Ğ¾Ğ´Ğ¸Ğ¼ @ 0.3730 Ñ Ğ¿ĞµÑ€ĞµÑÑ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ targets
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

```json
{
  "SignalBot": {
    "Entry": {
      "MaxPriceDeviationPercent": 0.5,
      "DeviationAction": "Skip",
      "UseLimitOrder": false,
      "LimitPricing": "AtEntry",
      "LimitOrderTtl": "00:05:00",
      "MaxSlippagePercent": 0.3
    }
  }
}
```

---

## Cooldown Ğ¿Ğ¾ÑĞ»Ğµ ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²

### ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°

ĞŸĞ¾ÑĞ»Ğµ ÑÑ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑĞ° Ñ‚Ñ€ĞµĞ¹Ğ´ĞµÑ€ Ñ‡Ğ°ÑÑ‚Ğ¾ Ñ…Ğ¾Ñ‡ĞµÑ‚ "Ğ¾Ñ‚Ñ‹Ğ³Ñ€Ğ°Ñ‚ÑŒÑÑ" Ğ¸ Ğ²Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ² ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Ñ‚Ñ€ĞµĞ¹Ğ´ Ğ¸Ğ¼Ğ¿ÑƒĞ»ÑŒÑĞ¸Ğ²Ğ½Ğ¾. Ğ‘Ğ¾Ñ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚ ÑÑ‚Ğ¾Ğ³Ğ¾.

### ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸

```csharp
public record CooldownSettings
{
    /// <summary>
    /// Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ cooldown
    /// </summary>
    public bool Enabled { get; init; } = true;

    /// <summary>
    /// ĞŸĞ°ÑƒĞ·Ğ° Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ÑÑ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑĞ°
    /// </summary>
    public TimeSpan CooldownAfterStopLoss { get; init; } = TimeSpan.FromMinutes(15);

    /// <summary>
    /// ĞŸĞ°ÑƒĞ·Ğ° Ğ¿Ğ¾ÑĞ»Ğµ Ğ»Ğ¸ĞºĞ²Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ (ĞµÑĞ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ°)
    /// </summary>
    public TimeSpan CooldownAfterLiquidation { get; init; } = TimeSpan.FromHours(1);

    /// <summary>
    /// ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ² Ğ¿Ğ¾Ğ´Ñ€ÑĞ´ Ğ´Ğ»Ñ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğ³Ğ¾ cooldown
    /// </summary>
    public int ConsecutiveLossesForLongCooldown { get; init; } = 3;

    /// <summary>
    /// Ğ”Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğ¹ cooldown Ğ¿Ğ¾ÑĞ»Ğµ ÑĞµÑ€Ğ¸Ğ¸ ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²
    /// </summary>
    public TimeSpan LongCooldownDuration { get; init; } = TimeSpan.FromHours(2);

    /// <summary>
    /// Ğ£Ğ¼ĞµĞ½ÑŒÑˆĞ¸Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ÑĞ»Ğµ ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²
    /// </summary>
    public bool ReduceSizeAfterLosses { get; init; } = true;

    /// <summary>
    /// ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾ÑĞ»Ğµ 1 ÑƒĞ±Ñ‹Ñ‚ĞºĞ°
    /// </summary>
    public decimal SizeMultiplierAfter1Loss { get; init; } = 0.75m;

    /// <summary>
    /// ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾ÑĞ»Ğµ 2 ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ² Ğ¿Ğ¾Ğ´Ñ€ÑĞ´
    /// </summary>
    public decimal SizeMultiplierAfter2Losses { get; init; } = 0.5m;

    /// <summary>
    /// ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° Ğ¿Ğ¾ÑĞ»Ğµ 3+ ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ² Ğ¿Ğ¾Ğ´Ñ€ÑĞ´
    /// </summary>
    public decimal SizeMultiplierAfter3PlusLosses { get; init; } = 0.25m;

    /// <summary>
    /// Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‚Ñ€ĞµĞ¹Ğ´Ğ¾Ğ² Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ»Ñ ÑĞ±Ñ€Ğ¾ÑĞ° ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸ĞºĞ° ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²
    /// </summary>
    public int WinsToResetLossCounter { get; init; } = 2;
}
```

### Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹

```
                     ĞŸĞ¾Ğ·Ğ¸Ñ†Ğ¸Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ°
                           â”‚
                           â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°       â”‚
                   â”‚ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ?     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                 â”‚                 â”‚
    StopLoss          TargetHit         Liquidation
         â”‚                 â”‚                 â”‚
         â–¼                 â–¼                 â–¼
   consecutiveLosses++   consecutiveLosses=0   consecutiveLosses++
         â”‚                 â”‚                 â”‚
         â–¼                 â–¼                 â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   ĞĞµÑ‚ cooldown    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ consecutiveLosses                 â”‚ Ğ”Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğ¹       â”‚
   â”‚ >= 3?         â”‚                   â”‚ cooldown      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚ (1 Ñ‡Ğ°Ñ)       â”‚
           â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
   Ğ”Ğ°            ĞĞµÑ‚
    â”‚             â”‚
    â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ğ”Ğ»Ğ¸Ğ½Ğ½Ñ‹Ğ¹ â”‚  â”‚ ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹     â”‚
â”‚ cooldownâ”‚  â”‚ cooldown    â”‚
â”‚ (2 Ñ‡Ğ°ÑĞ°)â”‚  â”‚ (15 Ğ¼Ğ¸Ğ½)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CooldownManager

```csharp
public class CooldownManager
{
    private readonly CooldownSettings _settings;
    private readonly ILogger<CooldownManager> _logger;

    private int _consecutiveLosses = 0;
    private int _consecutiveWins = 0;
    private DateTime? _cooldownUntil = null;
    private string? _cooldownReason = null;

    public bool IsInCooldown => _cooldownUntil.HasValue && DateTime.UtcNow < _cooldownUntil.Value;

    public TimeSpan? RemainingCooldown => IsInCooldown
        ? _cooldownUntil!.Value - DateTime.UtcNow
        : null;

    public CooldownStatus GetStatus()
    {
        return new CooldownStatus
        {
            IsInCooldown = IsInCooldown,
            CooldownUntil = _cooldownUntil,
            RemainingTime = RemainingCooldown,
            Reason = _cooldownReason,
            ConsecutiveLosses = _consecutiveLosses,
            CurrentSizeMultiplier = GetCurrentSizeMultiplier()
        };
    }

    public void OnPositionClosed(SignalPosition position)
    {
        if (!_settings.Enabled) return;

        switch (position.CloseReason)
        {
            case PositionCloseReason.StopLossHit:
                HandleStopLoss();
                break;

            case PositionCloseReason.Liquidation:
                HandleLiquidation();
                break;

            case PositionCloseReason.AllTargetsHit:
                HandleWin();
                break;

            // Partial close Ğ¸Ğ»Ğ¸ manual - Ğ½Ğµ Ğ²Ğ»Ğ¸ÑÑÑ‚ Ğ½Ğ° cooldown
        }
    }

    private void HandleStopLoss()
    {
        _consecutiveLosses++;
        _consecutiveWins = 0;

        TimeSpan cooldown = _consecutiveLosses >= _settings.ConsecutiveLossesForLongCooldown
            ? _settings.LongCooldownDuration
            : _settings.CooldownAfterStopLoss;

        SetCooldown(cooldown, $"Stop loss #{_consecutiveLosses}");

        _logger.LogWarning(
            "Cooldown activated: {Duration} after {Losses} consecutive losses",
            cooldown, _consecutiveLosses);
    }

    private void HandleLiquidation()
    {
        _consecutiveLosses++;
        _consecutiveWins = 0;

        SetCooldown(_settings.CooldownAfterLiquidation, "Liquidation");

        _logger.LogError("Cooldown activated after LIQUIDATION: {Duration}",
            _settings.CooldownAfterLiquidation);
    }

    private void HandleWin()
    {
        _consecutiveWins++;

        if (_consecutiveWins >= _settings.WinsToResetLossCounter)
        {
            _consecutiveLosses = 0;
            _consecutiveWins = 0;
            _logger.LogInformation("Loss counter reset after {Wins} consecutive wins",
                _settings.WinsToResetLossCounter);
        }
    }

    private void SetCooldown(TimeSpan duration, string reason)
    {
        _cooldownUntil = DateTime.UtcNow + duration;
        _cooldownReason = reason;
    }

    public decimal GetCurrentSizeMultiplier()
    {
        if (!_settings.ReduceSizeAfterLosses) return 1.0m;

        return _consecutiveLosses switch
        {
            0 => 1.0m,
            1 => _settings.SizeMultiplierAfter1Loss,
            2 => _settings.SizeMultiplierAfter2Losses,
            _ => _settings.SizeMultiplierAfter3PlusLosses
        };
    }

    /// <summary>
    /// ĞŸÑ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ ÑĞ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ cooldown (Ğ´Ğ»Ñ manual override)
    /// </summary>
    public void ForceResetCooldown()
    {
        _cooldownUntil = null;
        _cooldownReason = null;
        _logger.LogWarning("Cooldown manually reset");
    }

    /// <summary>
    /// ĞŸÑ€Ğ¸Ğ½ÑƒĞ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ ÑĞ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸Ğº ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²
    /// </summary>
    public void ForceResetLossCounter()
    {
        _consecutiveLosses = 0;
        _consecutiveWins = 0;
        _logger.LogWarning("Loss counter manually reset");
    }
}

public record CooldownStatus
{
    public bool IsInCooldown { get; init; }
    public DateTime? CooldownUntil { get; init; }
    public TimeSpan? RemainingTime { get; init; }
    public string? Reason { get; init; }
    public int ConsecutiveLosses { get; init; }
    public decimal CurrentSizeMultiplier { get; init; }
}
```

### Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ SignalProcessor

```csharp
public async Task<SignalProcessingResult> ProcessSignalAsync(TradingSignal signal, CancellationToken ct)
{
    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ cooldown
    if (_cooldownManager.IsInCooldown)
    {
        var status = _cooldownManager.GetStatus();
        _logger.LogInformation(
            "Signal skipped: in cooldown for {Remaining} ({Reason})",
            status.RemainingTime, status.Reason);

        return SignalProcessingResult.Skipped(
            $"In cooldown: {status.RemainingTime:mm\\:ss} remaining ({status.Reason})");
    }

    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¼Ğ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°
    decimal sizeMultiplier = _cooldownManager.GetCurrentSizeMultiplier();

    if (sizeMultiplier < 1.0m)
    {
        _logger.LogInformation(
            "Position size reduced to {Multiplier:P0} due to {Losses} consecutive losses",
            sizeMultiplier, _cooldownManager.GetStatus().ConsecutiveLosses);
    }

    // ... Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ñ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞµĞ½Ğ½Ñ‹Ğ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ¾Ğ¼
}
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

```json
{
  "SignalBot": {
    "Cooldown": {
      "Enabled": true,
      "CooldownAfterStopLoss": "00:15:00",
      "CooldownAfterLiquidation": "01:00:00",
      "ConsecutiveLossesForLongCooldown": 3,
      "LongCooldownDuration": "02:00:00",
      "ReduceSizeAfterLosses": true,
      "SizeMultiplierAfter1Loss": 0.75,
      "SizeMultiplierAfter2Losses": 0.5,
      "SizeMultiplierAfter3PlusLosses": 0.25,
      "WinsToResetLossCounter": 2
    }
  }
}
```

---

## Emergency Controls / Ğ ÑƒÑ‡Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ

### ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°

ĞÑƒĞ¶Ğ½Ğ° Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ:
- ĞĞ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ¾ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ°
- Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹
- ĞŸÑ€Ğ¸Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºÑƒÑ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ñ
- Ğ’Ñ€ÑƒÑ‡Ğ½ÑƒÑ Ğ²Ğ¼ĞµÑˆĞ°Ñ‚ÑŒÑÑ Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ

### Ğ ĞµĞ¶Ğ¸Ğ¼Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ±Ğ¾Ñ‚Ğ°

```csharp
public enum BotOperatingMode
{
    /// <summary>
    /// ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼
    /// </summary>
    Automatic,

    /// <summary>
    /// Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³, Ğ½Ğ¾Ğ²Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒÑÑ‚ÑÑ
    /// Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‚ÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
    /// </summary>
    MonitorOnly,

    /// <summary>
    /// ĞŸĞ°ÑƒĞ·Ğ° - Ğ½Ğ¸Ñ‡ĞµĞ³Ğ¾ Ğ½Ğµ Ğ´ĞµĞ»Ğ°ĞµĞ¼, Ğ½Ğ¾ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ
    /// </summary>
    Paused,

    /// <summary>
    /// ĞĞ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° - Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑÑ‘
    /// </summary>
    EmergencyStop
}
```

### Emergency Settings

```csharp
public record EmergencySettings
{
    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ´Ğ½ĞµĞ²Ğ½Ğ¾Ğ¹ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº (% Ğ¾Ñ‚ ĞºĞ°Ğ¿Ğ¸Ñ‚Ğ°Ğ»Ğ°)
    /// ĞŸÑ€Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¸ - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°
    /// </summary>
    public decimal MaxDailyLossPercent { get; init; } = 5m;

    /// <summary>
    /// ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº Ğ·Ğ° ÑĞµÑÑĞ¸Ñ
    /// </summary>
    public decimal MaxSessionLossPercent { get; init; } = 10m;

    /// <summary>
    /// Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¸ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ° ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²
    /// </summary>
    public MaxLossAction MaxLossAction { get; init; } = MaxLossAction.StopNewTrades;

    /// <summary>
    /// ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸ Ğ°Ğ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ¾Ğ¹ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ
    /// </summary>
    public bool CloseAllOnEmergencyStop { get; init; } = true;

    /// <summary>
    /// Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¸ Ğ°Ğ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ¾Ğ¹ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞµ
    /// </summary>
    public bool NotifyOnEmergencyStop { get; init; } = true;

    /// <summary>
    /// Webhook URL Ğ´Ğ»Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
    /// </summary>
    public string? EmergencyWebhookUrl { get; init; }
}

public enum MaxLossAction
{
    /// <summary>
    /// Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ‚Ñ€ĞµĞ¹Ğ´Ñ‹, Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ
    /// </summary>
    StopNewTrades,

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ¸ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ
    /// </summary>
    CloseAllAndStop,

    /// <summary>
    /// Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ
    /// </summary>
    NotifyOnly
}
```

### BotController - Ñ†ĞµĞ½Ñ‚Ñ€ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ

```csharp
public class BotController
{
    private readonly IPositionManager _positionManager;
    private readonly IBinanceFuturesClient _client;
    private readonly INotifier _notifier;
    private readonly ILogger<BotController> _logger;
    private readonly EmergencySettings _settings;

    private BotOperatingMode _currentMode = BotOperatingMode.Automatic;
    private decimal _sessionStartEquity;
    private decimal _dailyStartEquity;
    private DateTime _dailyResetTime;

    public BotOperatingMode CurrentMode => _currentMode;

    /// <summary>
    /// ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹
    /// </summary>
    public async Task SetModeAsync(BotOperatingMode mode, CancellationToken ct = default)
    {
        var previousMode = _currentMode;
        _currentMode = mode;

        _logger.LogWarning("Bot mode changed: {Previous} â†’ {New}", previousMode, mode);

        switch (mode)
        {
            case BotOperatingMode.EmergencyStop:
                await HandleEmergencyStopAsync(ct);
                break;

            case BotOperatingMode.Paused:
                await _notifier.SendAlertAsync("â¸ï¸ Bot Paused",
                    "Automatic trading paused. Positions remain open.", ct);
                break;

            case BotOperatingMode.MonitorOnly:
                await _notifier.SendMessageAsync(
                    "ğŸ‘ï¸ Bot switched to Monitor Only mode. New signals will be ignored.", ct);
                break;

            case BotOperatingMode.Automatic:
                await _notifier.SendMessageAsync(
                    "âœ… Bot resumed automatic trading.", ct);
                break;
        }
    }

    /// <summary>
    /// ĞĞ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°
    /// </summary>
    public async Task EmergencyStopAsync(string reason, CancellationToken ct = default)
    {
        _logger.LogCritical("EMERGENCY STOP initiated: {Reason}", reason);

        _currentMode = BotOperatingMode.EmergencyStop;

        // Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ
        await _notifier.SendAlertAsync(
            "ğŸš¨ EMERGENCY STOP",
            $"Reason: {reason}\nClosing all positions...",
            ct);

        // Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
        if (_settings.CloseAllOnEmergencyStop)
        {
            await CloseAllPositionsAsync("Emergency stop", ct);
        }

        // Webhook
        if (!string.IsNullOrEmpty(_settings.EmergencyWebhookUrl))
        {
            await SendEmergencyWebhookAsync(reason, ct);
        }
    }

    /// <summary>
    /// Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    /// </summary>
    public async Task<CloseAllResult> CloseAllPositionsAsync(
        string reason,
        CancellationToken ct = default)
    {
        var openPositions = await _positionManager.GetOpenPositionsAsync(ct);

        _logger.LogWarning("Closing {Count} positions: {Reason}",
            openPositions.Count, reason);

        var results = new List<PositionCloseResult>();

        foreach (var position in openPositions)
        {
            try
            {
                // ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
                await CancelAllOrdersForPositionAsync(position, ct);

                // Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾ Ñ€Ñ‹Ğ½ĞºÑƒ
                var closeResult = await _client.PlaceMarketOrderAsync(new OrderRequest
                {
                    Symbol = position.Symbol,
                    Side = position.Direction == SignalDirection.Long
                        ? OrderSide.Sell
                        : OrderSide.Buy,
                    Quantity = position.RemainingQuantity,
                    ReduceOnly = true
                }, ct);

                results.Add(new PositionCloseResult
                {
                    Position = position,
                    Success = closeResult.IsSuccess,
                    ClosePrice = closeResult.AveragePrice,
                    Error = closeResult.Error
                });

                _logger.LogInformation("Closed {Symbol} @ {Price}",
                    position.Symbol, closeResult.AveragePrice);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to close position {Symbol}", position.Symbol);
                results.Add(new PositionCloseResult
                {
                    Position = position,
                    Success = false,
                    Error = ex.Message
                });
            }
        }

        var totalPnl = results.Where(r => r.Success).Sum(r => r.RealizedPnl);

        await _notifier.SendMessageAsync(
            $"ğŸ“Š Closed {results.Count(r => r.Success)}/{openPositions.Count} positions\n" +
            $"Total PnL: {totalPnl:+0.00;-0.00} USDT\n" +
            $"Reason: {reason}",
            ct);

        return new CloseAllResult
        {
            TotalPositions = openPositions.Count,
            ClosedSuccessfully = results.Count(r => r.Success),
            Failed = results.Count(r => !r.Success),
            TotalPnl = totalPnl,
            Results = results
        };
    }

    /// <summary>
    /// ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ° (Ğ±ĞµĞ· Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¹)
    /// </summary>
    public async Task CancelAllOrdersAsync(CancellationToken ct = default)
    {
        var openPositions = await _positionManager.GetOpenPositionsAsync(ct);

        foreach (var position in openPositions)
        {
            await CancelAllOrdersForPositionAsync(position, ct);
        }

        _logger.LogWarning("All orders cancelled for {Count} positions", openPositions.Count);
    }

    /// <summary>
    /// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğ¾Ğ² ÑƒĞ±Ñ‹Ñ‚ĞºĞ¾Ğ²
    /// </summary>
    public async Task CheckLossLimitsAsync(CancellationToken ct = default)
    {
        // Ğ¡Ğ±Ñ€Ğ¾Ñ Ğ´Ğ½ĞµĞ²Ğ½Ğ¾Ğ³Ğ¾ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸ĞºĞ° Ğ² Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ‡ÑŒ UTC
        if (DateTime.UtcNow.Date > _dailyResetTime.Date)
        {
            var account = await _client.GetAccountInfoAsync(ct);
            _dailyStartEquity = account.TotalWalletBalance;
            _dailyResetTime = DateTime.UtcNow;
        }

        var currentAccount = await _client.GetAccountInfoAsync(ct);
        decimal currentEquity = currentAccount.TotalWalletBalance;

        // Ğ”Ğ½ĞµĞ²Ğ½Ğ¾Ğ¹ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº
        decimal dailyLossPercent = (_dailyStartEquity - currentEquity) / _dailyStartEquity * 100;

        if (dailyLossPercent >= _settings.MaxDailyLossPercent)
        {
            _logger.LogCritical("Daily loss limit reached: {Loss:F2}%", dailyLossPercent);
            await HandleMaxLossAsync($"Daily loss limit: {dailyLossPercent:F2}%", ct);
            return;
        }

        // Ğ¡ĞµÑÑĞ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº
        decimal sessionLossPercent = (_sessionStartEquity - currentEquity) / _sessionStartEquity * 100;

        if (sessionLossPercent >= _settings.MaxSessionLossPercent)
        {
            _logger.LogCritical("Session loss limit reached: {Loss:F2}%", sessionLossPercent);
            await HandleMaxLossAsync($"Session loss limit: {sessionLossPercent:F2}%", ct);
        }
    }

    private async Task HandleMaxLossAsync(string reason, CancellationToken ct)
    {
        switch (_settings.MaxLossAction)
        {
            case MaxLossAction.StopNewTrades:
                await SetModeAsync(BotOperatingMode.MonitorOnly, ct);
                await _notifier.SendAlertAsync("âš ï¸ Loss Limit Reached",
                    $"{reason}\nNew trades stopped. Positions remain open.", ct);
                break;

            case MaxLossAction.CloseAllAndStop:
                await EmergencyStopAsync(reason, ct);
                break;

            case MaxLossAction.NotifyOnly:
                await _notifier.SendAlertAsync("âš ï¸ Loss Limit Warning",
                    $"{reason}\nContinuing to trade.", ct);
                break;
        }
    }

    private async Task HandleEmergencyStopAsync(CancellationToken ct)
    {
        await _notifier.SendAlertAsync("ğŸš¨ EMERGENCY STOP ACTIVATED",
            "Closing all positions and stopping bot.", ct);

        if (_settings.CloseAllOnEmergencyStop)
        {
            await CloseAllPositionsAsync("Emergency stop", ct);
        }
    }
}

public record CloseAllResult
{
    public int TotalPositions { get; init; }
    public int ClosedSuccessfully { get; init; }
    public int Failed { get; init; }
    public decimal TotalPnl { get; init; }
    public IReadOnlyList<PositionCloseResult> Results { get; init; } = [];
}

public record PositionCloseResult
{
    public SignalPosition Position { get; init; } = null!;
    public bool Success { get; init; }
    public decimal ClosePrice { get; init; }
    public decimal RealizedPnl { get; init; }
    public string? Error { get; init; }
}
```

### ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ (Telegram Bot / CLI)

```csharp
public interface IBotCommands
{
    /// <summary>
    /// /status - Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    /// </summary>
    Task<string> GetStatusAsync(CancellationToken ct = default);

    /// <summary>
    /// /pause - Ğ¿Ñ€Ğ¸Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ñ
    /// </summary>
    Task PauseAsync(CancellationToken ct = default);

    /// <summary>
    /// /resume - Ğ²Ğ¾Ğ·Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ñ€Ğ³Ğ¾Ğ²Ğ»Ñ
    /// </summary>
    Task ResumeAsync(CancellationToken ct = default);

    /// <summary>
    /// /stop - Ğ°Ğ²Ğ°Ñ€Ğ¸Ğ¹Ğ½Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ°
    /// </summary>
    Task EmergencyStopAsync(CancellationToken ct = default);

    /// <summary>
    /// /closeall - Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ²ÑĞµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    /// </summary>
    Task CloseAllAsync(CancellationToken ct = default);

    /// <summary>
    /// /close BTCUSDT - Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
    /// </summary>
    Task ClosePositionAsync(string symbol, CancellationToken ct = default);

    /// <summary>
    /// /cancelorders - Ğ¾Ñ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ¾Ñ€Ğ´ĞµÑ€Ğ°
    /// </summary>
    Task CancelAllOrdersAsync(CancellationToken ct = default);

    /// <summary>
    /// /resetcooldown - ÑĞ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ cooldown
    /// </summary>
    Task ResetCooldownAsync(CancellationToken ct = default);

    /// <summary>
    /// /positions - Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸
    /// </summary>
    Task<string> GetPositionsAsync(CancellationToken ct = default);

    /// <summary>
    /// /pnl - Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ P&L Ğ·Ğ° ÑĞµÑÑĞ¸Ñ/Ğ´ĞµĞ½ÑŒ
    /// </summary>
    Task<string> GetPnlAsync(CancellationToken ct = default);
}
```

### ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´

```csharp
public class TelegramBotCommands : IBotCommands
{
    private readonly BotController _controller;
    private readonly CooldownManager _cooldownManager;
    private readonly IPositionManager _positionManager;

    public async Task<string> GetStatusAsync(CancellationToken ct = default)
    {
        var positions = await _positionManager.GetOpenPositionsAsync(ct);
        var cooldown = _cooldownManager.GetStatus();

        var sb = new StringBuilder();
        sb.AppendLine($"ğŸ¤– **Bot Status**");
        sb.AppendLine($"Mode: {_controller.CurrentMode}");
        sb.AppendLine($"Open positions: {positions.Count}");

        if (cooldown.IsInCooldown)
        {
            sb.AppendLine($"â³ Cooldown: {cooldown.RemainingTime:mm\\:ss} ({cooldown.Reason})");
        }

        if (cooldown.ConsecutiveLosses > 0)
        {
            sb.AppendLine($"ğŸ“‰ Consecutive losses: {cooldown.ConsecutiveLosses}");
            sb.AppendLine($"ğŸ“Š Size multiplier: {cooldown.CurrentSizeMultiplier:P0}");
        }

        return sb.ToString();
    }

    public async Task<string> GetPositionsAsync(CancellationToken ct = default)
    {
        var positions = await _positionManager.GetOpenPositionsAsync(ct);

        if (!positions.Any())
            return "ğŸ“­ No open positions";

        var sb = new StringBuilder();
        sb.AppendLine("ğŸ“Š **Open Positions**\n");

        foreach (var pos in positions)
        {
            var emoji = pos.Direction == SignalDirection.Long ? "ğŸŸ¢" : "ğŸ”´";
            var pnlEmoji = pos.UnrealizedPnl >= 0 ? "ğŸ“ˆ" : "ğŸ“‰";

            sb.AppendLine($"{emoji} **{pos.Symbol}** {pos.Direction}");
            sb.AppendLine($"   Entry: {pos.ActualEntryPrice}");
            sb.AppendLine($"   SL: {pos.CurrentStopLoss}");
            sb.AppendLine($"   Qty: {pos.RemainingQuantity}");
            sb.AppendLine($"   {pnlEmoji} PnL: {pos.UnrealizedPnl:+0.00;-0.00} USDT");
            sb.AppendLine($"   Targets hit: {pos.TargetsHit}/{pos.Targets.Count}");
            sb.AppendLine();
        }

        return sb.ToString();
    }
}
```

### ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ

```json
{
  "SignalBot": {
    "Emergency": {
      "MaxDailyLossPercent": 5.0,
      "MaxSessionLossPercent": 10.0,
      "MaxLossAction": "StopNewTrades",
      "CloseAllOnEmergencyStop": true,
      "NotifyOnEmergencyStop": true,
      "EmergencyWebhookUrl": null
    },

    "Commands": {
      "EnableTelegramCommands": true,
      "AllowedUserIds": [123456789],
      "RequireConfirmation": ["closeall", "stop"]
    }
  }
}
```

### Telegram ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´

```
ğŸ‘¤ Command received: /pause

â¸ï¸ Bot Paused
Trading paused. 3 positions remain open.
Use /resume to continue or /closeall to exit.

---

ğŸ‘¤ Command received: /closeall
âš ï¸ Are you sure? Reply /closeall confirm

ğŸ‘¤ /closeall confirm

ğŸ“Š Closing 3 positions...
âœ… BTCUSDT closed @ 43250.50 (+12.35 USDT)
âœ… ETHUSDT closed @ 2250.25 (-5.20 USDT)
âœ… SOLUSDT closed @ 98.15 (+3.80 USDT)

Total PnL: +10.95 USDT

---

ğŸš¨ EMERGENCY STOP
Reason: Daily loss limit: 5.12%
All positions closed.
Bot is now stopped. Manual restart required.
```

---

## TODO / Ğ‘ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ

- [ ] ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ñ… Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¾Ğ² ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ĞºĞ°Ğ½Ğ°Ğ»Ñ‹)
- [ ] Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¿Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ğ¼ (whitelist/blacklist)
- [ ] ĞÑ‚Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ²Ñ…Ğ¾Ğ´ (Limit order Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Market)
- [ ] Trailing stop Ğ¿Ğ¾ÑĞ»Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ target
- [ ] Dashboard Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° (web UI)
- [ ] Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾ ĞºĞ°Ğ½Ğ°Ğ»Ğ°Ğ¼ (ĞºĞ°ĞºĞ¾Ğ¹ ĞºĞ°Ğ½Ğ°Ğ» Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ğ»ÑŒĞ½ĞµĞµ)
- [ ] Backtest ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¸Ğ· Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸ ĞºĞ°Ğ½Ğ°Ğ»Ğ°
- [ ] Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Discord
- [ ] ĞœĞ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ push-ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ

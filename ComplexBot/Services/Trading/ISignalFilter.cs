using ComplexBot.Models;

namespace ComplexBot.Services.Trading;

/// <summary>
/// Interface for filtering trading signals based on additional criteria.
/// Used in multi-timeframe analysis where a filter strategy (e.g., RSI on 1h)
/// can confirm, veto, or score signals from a primary strategy (e.g., ADX on 4h).
/// </summary>
public interface ISignalFilter
{
    /// <summary>
    /// Name of the filter for logging and identification.
    /// </summary>
    string Name { get; }

    /// <summary>
    /// How this filter affects signal decisions.
    /// </summary>
    FilterMode Mode { get; }

    /// <summary>
    /// Evaluates whether to approve a trading signal based on filter strategy state.
    /// </summary>
    /// <param name="signal">The signal from the primary strategy</param>
    /// <param name="filterState">Current state of the filter strategy</param>
    /// <returns>Result indicating approval status and reasoning</returns>
    FilterResult Evaluate(TradeSignal signal, StrategyState filterState);
}

/// <summary>
/// Defines how a filter affects signal decisions.
/// </summary>
public enum FilterMode
{
    /// <summary>
    /// Signal must be explicitly confirmed by filter to proceed.
    /// If filter returns Approved=false, signal is rejected.
    /// </summary>
    Confirm,

    /// <summary>
    /// Filter can veto signals but doesn't need to confirm.
    /// Only if filter explicitly rejects (Approved=false) is signal blocked.
    /// </summary>
    Veto,

    /// <summary>
    /// Filter adjusts signal confidence/position sizing but doesn't block.
    /// Uses ConfidenceAdjustment (0.0 - 1.0) to scale position size.
    /// </summary>
    Score
}

/// <summary>
/// Result of a filter evaluation.
/// </summary>
/// <param name="Approved">Whether the filter approves the signal (Confirm/Veto modes)</param>
/// <param name="Reason">Human-readable explanation of the decision</param>
/// <param name="ConfidenceAdjustment">Optional confidence multiplier for Score mode (0.0 - 1.0)</param>
public record FilterResult(
    bool Approved,
    string Reason,
    decimal? ConfidenceAdjustment = null
);

/// <summary>
/// Snapshot of a strategy's current state for filter evaluation.
/// Allows filters to make decisions based on indicator values without tight coupling.
/// </summary>
/// <param name="LastSignal">Most recent signal type generated by the strategy</param>
/// <param name="IndicatorValue">Primary indicator value (e.g., RSI value, ADX value)</param>
/// <param name="IsOverbought">Whether strategy indicators show overbought conditions</param>
/// <param name="IsOversold">Whether strategy indicators show oversold conditions</param>
/// <param name="IsTrending">Whether strategy detects a trending market</param>
/// <param name="CustomValues">Additional strategy-specific values</param>
public record StrategyState(
    SignalType? LastSignal,
    decimal? IndicatorValue,
    bool IsOverbought,
    bool IsOversold,
    bool IsTrending,
    Dictionary<string, decimal> CustomValues
)
{
    /// <summary>
    /// Creates an empty state (used when no filter strategy exists).
    /// </summary>
    public static StrategyState Empty => new(
        LastSignal: null,
        IndicatorValue: null,
        IsOverbought: false,
        IsOversold: false,
        IsTrending: false,
        CustomValues: new Dictionary<string, decimal>()
    );
}
